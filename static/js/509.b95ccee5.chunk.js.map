{"version":3,"file":"static/js/509.b95ccee5.chunk.js","mappings":"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","sources":["components/latex/Piecewise.tsx","topics/01-limits/11-confirming-continuity-over-an-interval/generate-question.tsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\r\nimport Latex from \"./Latex\";\r\nimport { PiecewiseFunction } from \"../../types/PiecewiseFunction\";\r\n\r\ninterface PiecewiseProps {\r\n  title: string,\r\n  functions: PiecewiseFunction[],\r\n  display?: string | boolean,\r\n  classes?: string\r\n}\r\n\r\nexport const Piecewise: React.FC<PiecewiseProps> = ({ title, functions, display, classes }) => {\r\n  const [expression, setExpression] = useState(``);\r\n  useEffect(() => {\r\n    if (functions) {\r\n      let e = `\\\\begin{cases}`;\r\n      for (let i = 0; i < functions.length; i++) {\r\n        e = e + functions[i].f + \"&\";\r\n        e = e + functions[i].domain;\r\n        if (i !== functions.length - 1) {\r\n          e = e + \"\\\\\\\\\\\\\\\\\"\r\n        }\r\n      }\r\n      e = e + \"\\\\end{cases}\"\r\n      setExpression(e)\r\n    }\r\n  },[functions])\r\n  \r\n  return (\r\n    <>\r\n      <Latex classes={classes ? classes : \"\"} expression={`${title ? `${title} = ` : ''} ${expression}`} display={display} />\r\n    </>\r\n  )\r\n}","import { formatPolynomialToLatex, getCoeffsOfPolynomial, getRandomNumber, getRandomWithExclusions, getRootsOfPolynomial, getStringFactorFromXval, sortPolynomialByDegree } from \"../../../helpers/functions\"\r\nimport { getPolynomialFunctionWithPoint } from \"../../../helpers/expression-generators\"\r\nimport * as math from \"mathjs\"\r\nimport { PiecewiseFunction } from \"../../../types/PiecewiseFunction\"\r\nimport { Piecewise } from \"../../../components/latex/Piecewise\"\r\nimport React from \"react\"\r\nimport Latex from \"../../../components/latex/Latex\"\r\nimport { Option } from \"../../../types/Option\"\r\n\r\nconst nerdamer = require(\"nerdamer/all.min\")\r\n\r\nconst piecewiseQuestion = () => {\r\n  // need 1 point where function may or may not be continuous but will be included in the interval\r\n  // need endpoints (can be on the boundaries or not) that will be included in the interval\r\n  const continuousX = getRandomNumber(-3, 3);\r\n\r\n  // decide if domains will be \r\n  // 1. [(before ep1, ep1)], [(ep1, contX)], [(contX, beyond ep2)]\r\n  // 2. [(before ep1, contX)], [(contX, ep2)], [(ep2, beyond ep2)]\r\n  let firstOrSecond = getRandomNumber(0, 1)\r\n  let srF = getSqrtFunction(continuousX)\r\n\r\n  let endpoint1 = getRandomNumber(-7, continuousX - 1);\r\n  let endpoint2 = getRandomNumber(continuousX + 1, 7);\r\n\r\n  // get coeffs and roots of function\r\n  const coeffs = getCoeffsOfPolynomial(srF)\r\n  let sqRtFunction = coeffs[2] < 0 ? 1 : getRandomWithExclusions(0, 2, [1])\r\n  const roots = getRootsOfPolynomial(srF)\r\n  srF = `sqrt(${srF})`\r\n\r\n  // if 2 real roots, modify root function position (0-2) based on continuousX\r\n  if (!roots[0].includes(\"i\") && !roots[1].includes(\"i\") && Number(roots[0]) !== Number(roots[1])) {\r\n    const rootNumbers = [Number(roots[0]), Number(roots[1])]\r\n    rootNumbers.sort((a, b) => a - b) // sort in ascending order\r\n    sqRtFunction = continuousX < rootNumbers[0] ? 0 : continuousX > rootNumbers[1] ? 2 : 1\r\n\r\n    if (Math.ceil(rootNumbers[0]) === continuousX) {\r\n      firstOrSecond = 1\r\n    } else if (Math.floor(rootNumbers[1]) === continuousX) {\r\n      firstOrSecond = 0\r\n    }\r\n\r\n    if (firstOrSecond === 0 && sqRtFunction === 1) {\r\n      endpoint1 = getRandomNumber(Math.ceil(rootNumbers[0]), continuousX - 1)\r\n    } else if (firstOrSecond === 1 && sqRtFunction === 1) {\r\n      endpoint2 = getRandomNumber(continuousX + 1, Math.floor(rootNumbers[1]))\r\n    }\r\n  }\r\n\r\n  const b4EP1 = endpoint1 - getRandomNumber(1, 3) // value before endpoint 1\r\n  const bYEP2 = endpoint2 + getRandomNumber(1, 3) // value beyond endpoint 2\r\n\r\n  // generate other function positions\r\n  const ratFunction = getRandomWithExclusions(0, 2, [1, sqRtFunction])\r\n  const lnFunction = getRandomWithExclusions(0, 2, [sqRtFunction, ratFunction])\r\n  const functionTypes = [\"\", \"\", \"\"] // array keeping track of type of 3 functions\r\n  functionTypes[sqRtFunction] = \"root\"\r\n  functionTypes[lnFunction] = \"ln\"\r\n  functionTypes[ratFunction] = \"rat\"\r\n\r\n  let ans = getRandomNumber(0, 2) // correct answer option\r\n  ans = 0\r\n  const firstYAtContX = Math.round(math.evaluate(srF, { x: continuousX })); //srF's yVal\r\n  const secondYAtContX = (ans === 1) ? getRandomWithExclusions(-7, 7, [firstYAtContX, 0]) : firstYAtContX // based on answer determineif f should be continuous at contX\r\n  let defaultEpY: number | string; // default and other endpoint vals\r\n  let otherEpY: number | string;\r\n\r\n  const piecewiseFunctions: PiecewiseFunction[] = [] // array to keep track of functions\r\n\r\n  // generate domaing strings and left and right Xs based on firstOrSecond\r\n  const leftXs = [b4EP1]\r\n  const rightXs = []\r\n  const domains = []\r\n  if (firstOrSecond === 0) {\r\n    leftXs.push(endpoint1, continuousX)\r\n    rightXs.push(endpoint1, continuousX)\r\n    domains.push(`${leftXs[0]} < x \\\\leq ${rightXs[0]}`)\r\n    domains.push(`${leftXs[1]} < x \\\\leq ${rightXs[1]}`)\r\n    domains.push(`${leftXs[2]} < x \\\\leq ${bYEP2}`)\r\n  } else {\r\n    leftXs.push(continuousX, endpoint2)\r\n    rightXs.push(continuousX, endpoint2)\r\n    domains.push(`${leftXs[0]} < x \\\\leq ${rightXs[0]}`)\r\n    domains.push(`${leftXs[1]} < x < ${rightXs[1]}`)\r\n    domains.push(`${leftXs[2]} \\\\leq x \\\\leq ${bYEP2}`)\r\n  }\r\n  rightXs.push(bYEP2)\r\n\r\n  // generate xypairs of points that functions should have\r\n  const xYPairs = [[], [], []]\r\n  xYPairs[1][0] = continuousX\r\n  xYPairs[1][1] = secondYAtContX\r\n\r\n  // generate middle function first\r\n  piecewiseFunctions[1] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 1)\r\n\r\n  // based on answer decide if endoint should be included\r\n  // find ep value from middle function\r\n  if (sqRtFunction === 1) {\r\n    // if sqrt function in the middle use nerdamer to keep sqrt\r\n    defaultEpY = nerdamer(piecewiseFunctions[1].f)\r\n      .sub(`x`, firstOrSecond === 0 ? endpoint1 : endpoint2)\r\n      .simplify()\r\n      .toString();\r\n  } else {\r\n    defaultEpY = math.evaluate(piecewiseFunctions[1].f,\r\n      { x: firstOrSecond === 0 ? endpoint1 : endpoint2 })\r\n  }\r\n\r\n  // based on value of default and answer, determine other ep value\r\n  if (Number.isNaN(Number(defaultEpY))) {\r\n    otherEpY = (ans === 2) ? getRandomWithExclusions(-7, 7, [0]) : defaultEpY\r\n  } else {\r\n    defaultEpY = Number(defaultEpY)\r\n    otherEpY = (ans === 2) ? getRandomWithExclusions(-7, 7, [defaultEpY, 0]) : defaultEpY\r\n  }\r\n\r\n  // populate xypairs with x-values\r\n  xYPairs[0][0] = rightXs[0]\r\n  xYPairs[2][0] = leftXs[2]\r\n\r\n  // determine y values based on root function position and firstorsecond\r\n  if (firstOrSecond === 1) {\r\n    if (functionTypes[2] === \"root\") {\r\n      xYPairs[0][1] = firstYAtContX\r\n      // corrner case where srF accidentally has same endpoint val\r\n      if ((ans === 0) && Math.round(math.evaluate(srF, { x: endpoint2 })) !== otherEpY) {\r\n        ans = 2\r\n      } else if (ans === 2 && Math.round(math.evaluate(srF, { x: endpoint2 })) === defaultEpY) {\r\n        ans = 0\r\n      }\r\n    } else {\r\n      xYPairs[0][1] = secondYAtContX\r\n      xYPairs[2][1] = otherEpY\r\n    }\r\n  } else {\r\n    if (functionTypes[0] === \"root\") {\r\n      xYPairs[2][1] = firstYAtContX\r\n      // corrner case where srF accidentally has same endpoint val\r\n      if ((ans === 0) && Math.round(math.evaluate(srF, { x: endpoint1 })) !== otherEpY) {\r\n        ans = 2\r\n      } else if (ans === 2 && Math.round(math.evaluate(srF, { x: endpoint1 })) === defaultEpY) {\r\n        ans = 0\r\n      }\r\n    } else {\r\n      xYPairs[0][1] = otherEpY\r\n      xYPairs[2][1] = secondYAtContX\r\n    }\r\n  }\r\n\r\n  // generate other fs based on values computed above\r\n  piecewiseFunctions[0] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 0)\r\n  piecewiseFunctions[2] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 2)\r\n\r\n  // convert everything to latex\r\n  for (let i = 0; i < 3; i++) {\r\n    piecewiseFunctions[i].f = formatPolynomialToLatex(piecewiseFunctions[i].f)\r\n  }\r\n\r\n  const title = <h2>\r\n    Is <Latex expression=\"f(x)\" /> continous on <Latex expression={`[${endpoint1}, ${endpoint2}]`} />?\r\n  </h2>\r\n\r\n  const question = <div className=\"flex vertical center medium-gap\">\r\n    <Piecewise classes=\"large-font\" functions={piecewiseFunctions} title={`f(x)`} />\r\n  </div>\r\n\r\n  const hints: React.JSX.Element[] = [\r\n    <div>\r\n      <div className=\"flex vertical center medium-gap\">\r\n        <div>\r\n          Remember, we have 2 conditions to verify continuity on the closed interval <Latex expression={`[${endpoint1}, ${endpoint2}]`} /> for this function:\r\n        </div>\r\n        <Piecewise functions={piecewiseFunctions} title={`f(x)`} />\r\n      </div>\r\n      <div>\r\n        <ul className=\"text-start\">\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression=\"(a, b)\" />\r\n          </li>\r\n          <li>\r\n            <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to a^{\\\\footnotesize\\\\texttt{+}}} = f(a)`} /> and <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to b^{\\\\footnotesize\\\\texttt{-}}} = f(b)`} />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        Let's start with the first condition. First, it is worthwhile noting that at <Latex expression={`x = ${continuousX}`} />, there is a change in functions. Thus, for this condition, 3 things must be verified:\r\n      </div>\r\n      <div>\r\n        <ul className=\"text-start\">\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${continuousX})`} />\r\n          </li>\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous at <Latex expression={`x = ${continuousX}`} />\r\n          </li>\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${continuousX}, ${endpoint2})`} />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        For the first and third bullets, use the domains of the functions to determine whether they are continuous on those intervals.\r\n      </div>\r\n      <div>\r\n        For <Latex expression={`x = ${continuousX}`} />, do the process we learned in the last section to determine whether <Latex expression=\"f(x)\" /> is continuous at that point!\r\n      </div>\r\n    </div>,\r\n    <div className=\"flex vertical center medium-gap\">\r\n      <div>\r\n        If this verification fails, you automatically know <Latex expression=\"f(x)\" /> is not continuous on the given interval. If the verification passes, move on to the 2nd condition:\r\n      </div>\r\n      <div>\r\n        <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to a^{\\\\footnotesize\\\\texttt{+}}} = f(a)`} /> and <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to b^{\\\\footnotesize\\\\texttt{-}}} = f(b)`} />\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        Basically, ensure the respective one-sided limits equal the respective function values. If either of these verifications fail, you know <Latex expression=\"f(x)\" /> is not continous on the interval. However, if both pass, both conditions of continuity on an interval have passed! Therefore, you know <Latex expression=\"f(x)\" /> is continous on the interval.\r\n      </div>\r\n    </div>\r\n  ]\r\n\r\n  const options: Option[] = [\r\n    {\r\n      component: <div>\r\n        Yes, <Latex expression=\"f(x)\" /> is continous on <Latex expression={`[${endpoint1}, ${endpoint2}]`} />.\r\n      </div>,\r\n      correct: ans === 0\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is not continuous at <Latex expression={`x = ${continuousX}`} />, so it is not continous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />.\r\n      </div>,\r\n      correct: ans === 1\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />, but <Latex expression={`\\\\lim_{x \\\\to ${endpoint1}^{\\\\footnotesize\\\\texttt{+}}} f(x) \\\\neq f(${endpoint1})`} />.\r\n      </div>,\r\n      correct: ans === 2 && firstOrSecond === 0\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />, but <Latex expression={`\\\\lim_{x \\\\to ${endpoint2}^{\\\\footnotesize\\\\texttt{-}}} f(x) \\\\neq f(${endpoint2})`} />.\r\n      </div>,\r\n      correct: ans === 2 && firstOrSecond === 1\r\n    },\r\n  ]\r\n\r\n  return { title, question, type: 'mc', input: options, hints }\r\n}\r\n\r\n/**\r\n * Gets a sqrt function to use in above piecewise question\r\n * @param x x value at which there should be a squared y val on function\r\n * @returns sqrt function that has a wide enough domain\r\n */\r\nconst getSqrtFunction = (x: number) => {\r\n  let srF = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, getRandomNumber(1, 6) ** 2)\r\n  let roots = getRootsOfPolynomial(srF)\r\n\r\n  // keep generating function till it is valid for a wide enough domain\r\n  while (!roots[0].includes(\"i\") && !roots[1].includes(\"i\") &&\r\n    Number(roots[0]) !== Number(roots[1])) {\r\n    if (Math.floor(Number(roots[1])) - Math.ceil(Number(roots[0])) > 1) {\r\n      break;\r\n    }\r\n    srF = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, getRandomNumber(1, 6) ** 2)\r\n    roots = getRootsOfPolynomial(srF)\r\n  }\r\n\r\n  return srF\r\n}\r\n\r\n/**\r\n * Function generation helper method for above question\r\n * @param srF square root function\r\n * @param functions types of functions\r\n * @param xYPairs x, y pairs that function should have a point at\r\n * @param leftXs left domains\r\n * @param rightXs right domains\r\n * @param domains domain strings\r\n * @param i index to use in all arrays  \r\n * @returns piecewise function with generated function and domain\r\n */\r\nconst getFunctionHelper = (srF: string, functions: string[], xYPairs: Array<number>[],\r\n  leftXs: number[], rightXs: number[], domains: string[], i: number): PiecewiseFunction => {\r\n  // do srF in case the function is a root - otherwise, generate function normally\r\n  let f = srF;\r\n  if (functions[i] !== \"root\") {\r\n    f = generateFunction(functions[i], xYPairs[i][0], xYPairs[i][1], leftXs[i], rightXs[i])\r\n  }\r\n  return { f, domain: domains[i] }\r\n}\r\n\r\n/**\r\n * Generates specific function at (x, y)\r\n * @param type of function to generate\r\n * @param x value at which there should be a point\r\n * @param y value at which there should be a point\r\n * @param minValid x-value that function must be valid on\r\n * @param maxValid x-value that function must be valid on\r\n * @returns generated function string\r\n */\r\nconst generateFunction = (type: string, x: number, y: number | string,\r\n  minValid: number, maxValid: number) => {\r\n  if (type === \"ln\") {\r\n    const num: number = typeof y === \"string\" ? getRandomWithExclusions(-7, 7, [0]) : y\r\n    let node = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, num)\r\n    if (typeof y === \"string\") {\r\n      // if y is a string (sqrt), use nerdamer to simplify\r\n      node = `${nerdamer(`simplify(${y}/${num})`)}(${node})`\r\n    }\r\n    return `log(e^(${node}))`\r\n  } else if (type === \"rat\") {\r\n    // get factors with xvals that are beyond min and max valid\r\n    const f1 = getStringFactorFromXval(maxValid + getRandomNumber(1, 2))\r\n    const f2 = getStringFactorFromXval(minValid - getRandomNumber(1, 2))\r\n\r\n    const bottomExpression = sortPolynomialByDegree(nerdamer(`${f1}${f2}`).expand());\r\n    const bottom = math.evaluate(bottomExpression, { x })\r\n\r\n    // use nerdamer to simplify in case y is a sqrt\r\n    const top = nerdamer(`simplify((${bottom})(${y}))`).toString()\r\n    return `${top}/(${bottomExpression})`\r\n  }\r\n}\r\n\r\nconst generateRandomQuestion = () => {\r\n  return piecewiseQuestion()\r\n}\r\n\r\nexport default generateRandomQuestion\r\n\r\n// if there are 3 functions\r\n// functions will be [(before ep1, ep1)], [(ep1, contX)], [(contX, beyond ep2)]\r\n// or [(before ep1, contX)], [(contX, ep2)], [(ep2, beyond ep2)]\r\n\r\n// if there are 2 functions\r\n// functions will be [(endpoint1, continuousX)] and the other one will be [(continousX, endpoint2)]\r\n// functions may or may not be continous at endpoint1 and endpoint2\r\n\r\n// question: is f(x) continuous on [(endpoint1, endpoint2)]\r\n\r\n// answer format\r\n// Yes (ans = 0)\r\n// No, because f(x) is not continuous at continousX, so it is not continous on (endpoint1, endpoint2) (ans = 1)\r\n// No, because f(x) is continuous on (endpoint1, endpoint2), but lim_{x \\\\to endpoint1^+} \\\\neq f(endpoint1) (ans = 2)\r\n// IF [endpoint1, endpoint2]:\r\n// No, because f(x) is continuous on (endpoint1, endpoint2), but lim_{x \\\\to endpoint2^-} \\\\neq f(endpoint2) (ans = 3)\r\n// ELSE IF ONLY 1 []\r\n// No, because lim_{x \\\\to endpoint2^+} \\\\neq f(endpoint2) (lim from diff side) (ans = 3)\r\n"],"names":["Piecewise","_ref","title","functions","display","classes","_useState","useState","_useState2","_slicedToArray","expression","setExpression","useEffect","e","i","length","f","domain","_jsx","_Fragment","children","Latex","concat","nerdamer","require","getSqrtFunction","x","srF","getPolynomialFunctionWithPoint","getRandomNumber","Math","pow","roots","getRootsOfPolynomial","includes","Number","floor","ceil","getFunctionHelper","xYPairs","leftXs","rightXs","domains","generateFunction","type","y","minValid","maxValid","num","getRandomWithExclusions","node","f1","getStringFactorFromXval","f2","bottomExpression","sortPolynomialByDegree","expand","bottom","math","top","toString","continuousX","firstOrSecond","endpoint1","endpoint2","sqRtFunction","getCoeffsOfPolynomial","rootNumbers","sort","a","b","b4EP1","bYEP2","ratFunction","lnFunction","functionTypes","ans","defaultEpY","otherEpY","firstYAtContX","round","secondYAtContX","piecewiseFunctions","push","sub","simplify","isNaN","formatPolynomialToLatex","_jsxs","question","className","hints","input","component","correct","piecewiseQuestion"],"sourceRoot":""}