{"version":3,"file":"static/js/509.68e95e34.chunk.js","mappings":"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","sources":["components/latex/Piecewise.tsx","topics/01-limits/11-confirming-continuity-over-an-interval/generate-question.tsx"],"sourcesContent":["/**\r\n * Renders Piecewise Function in Latex\r\n */\r\nimport React, { useEffect, useState } from \"react\";\r\nimport Latex from \"./Latex\";\r\nimport { PiecewiseFunction } from \"../../@types/PiecewiseFunction\";\r\n\r\ninterface PiecewiseProps {\r\n  title: string, // name of function\r\n  functions: PiecewiseFunction[], // functions to show\r\n  display?: string | boolean, // whether it should be display mode\r\n  classes?: string // classes to apply\r\n}\r\n\r\nexport const Piecewise: React.FC<PiecewiseProps> = ({ title, functions, display, classes }) => {\r\n  const [expression, setExpression] = useState(``);\r\n  useEffect(() => {\r\n    if (functions) {\r\n      let e = `\\\\begin{cases}`;\r\n      for (let i = 0; i < functions.length; i++) {\r\n        e = e + functions[i].f + \"&\";\r\n        e = e + functions[i].domain;\r\n        if (i !== functions.length - 1) {\r\n          e = e + \"\\\\\\\\\\\\\\\\\"\r\n        }\r\n      }\r\n      e = e + \"\\\\end{cases}\"\r\n      setExpression(e)\r\n    }\r\n  },[functions])\r\n  \r\n  return (\r\n    <>\r\n      <Latex classes={classes ? classes : \"\"} expression={`${title ? `${title} = ` : ''} ${expression}`} display={display} />\r\n    </>\r\n  )\r\n}","import { formatPolynomialToLatex, getCoeffsOfPolynomial, getRandomNumber, getRandomWithExclusions, getRootsOfPolynomial, getStringFactorFromXval, sortPolynomialByDegree } from \"../../../helpers/functions\"\r\nimport { getPolynomialFunctionWithPoint } from \"../../../helpers/expression-generators\"\r\nimport * as math from \"mathjs\"\r\nimport { PiecewiseFunction } from \"../../../@types/PiecewiseFunction\"\r\nimport { Piecewise } from \"../../../components/latex/Piecewise\"\r\nimport React from \"react\"\r\nimport Latex from \"../../../components/latex/Latex\"\r\nimport { Option } from \"../../../@types/Option\"\r\n\r\nconst nerdamer = require(\"nerdamer/all.min\")\r\n\r\nconst piecewiseQuestion = () => {\r\n  // need 1 point where function may or may not be continuous but will be included in the interval\r\n  // need endpoints (can be on the boundaries or not) that will be included in the interval\r\n  const continuousX = getRandomNumber(-3, 3);\r\n\r\n  // decide if domains will be \r\n  // 1. [(before ep1, ep1)], [(ep1, contX)], [(contX, beyond ep2)]\r\n  // 2. [(before ep1, contX)], [(contX, ep2)], [(ep2, beyond ep2)]\r\n  let firstOrSecond = getRandomNumber(0, 1)\r\n  let srF = getSqrtFunction(continuousX)\r\n\r\n  let endpoint1 = getRandomNumber(-7, continuousX - 1);\r\n  let endpoint2 = getRandomNumber(continuousX + 1, 7);\r\n\r\n  // get coeffs and roots of function\r\n  const coeffs = getCoeffsOfPolynomial(srF)\r\n  let sqRtFunction = coeffs[2] < 0 ? 1 : getRandomWithExclusions(0, 2, [1])\r\n  const roots = getRootsOfPolynomial(srF)\r\n  srF = `sqrt(${srF})`\r\n\r\n  // if 2 real roots, modify root function position (0-2) based on continuousX\r\n  if (!roots[0].includes(\"i\") && !roots[1].includes(\"i\") && Number(roots[0]) !== Number(roots[1])) {\r\n    const rootNumbers = [Number(roots[0]), Number(roots[1])]\r\n    rootNumbers.sort((a, b) => a - b) // sort in ascending order\r\n    sqRtFunction = continuousX < rootNumbers[0] ? 0 : continuousX > rootNumbers[1] ? 2 : 1\r\n\r\n    if (Math.ceil(rootNumbers[0]) === continuousX) {\r\n      firstOrSecond = 1\r\n    } else if (Math.floor(rootNumbers[1]) === continuousX) {\r\n      firstOrSecond = 0\r\n    }\r\n\r\n    if (firstOrSecond === 0 && sqRtFunction === 1) {\r\n      endpoint1 = getRandomNumber(Math.ceil(rootNumbers[0]), continuousX - 1)\r\n    } else if (firstOrSecond === 1 && sqRtFunction === 1) {\r\n      endpoint2 = getRandomNumber(continuousX + 1, Math.floor(rootNumbers[1]))\r\n    }\r\n  }\r\n\r\n  const b4EP1 = endpoint1 - getRandomNumber(1, 3) // value before endpoint 1\r\n  const bYEP2 = endpoint2 + getRandomNumber(1, 3) // value beyond endpoint 2\r\n\r\n  // generate other function positions\r\n  const ratFunction = getRandomWithExclusions(0, 2, [1, sqRtFunction])\r\n  const lnFunction = getRandomWithExclusions(0, 2, [sqRtFunction, ratFunction])\r\n  const functionTypes = [\"\", \"\", \"\"] // array keeping track of type of 3 functions\r\n  functionTypes[sqRtFunction] = \"root\"\r\n  functionTypes[lnFunction] = \"ln\"\r\n  functionTypes[ratFunction] = \"rat\"\r\n\r\n  let ans = getRandomNumber(0, 2) // correct answer option\r\n  ans = 0\r\n  const firstYAtContX = Math.round(math.evaluate(srF, { x: continuousX })); //srF's yVal\r\n  const secondYAtContX = (ans === 1) ? getRandomWithExclusions(-7, 7, [firstYAtContX, 0]) : firstYAtContX // based on answer determineif f should be continuous at contX\r\n  let defaultEpY: number | string; // default and other endpoint vals\r\n  let otherEpY: number | string;\r\n\r\n  const piecewiseFunctions: PiecewiseFunction[] = [] // array to keep track of functions\r\n\r\n  // generate domaing strings and left and right Xs based on firstOrSecond\r\n  const leftXs = [b4EP1]\r\n  const rightXs = []\r\n  const domains = []\r\n  if (firstOrSecond === 0) {\r\n    leftXs.push(endpoint1, continuousX)\r\n    rightXs.push(endpoint1, continuousX)\r\n    domains.push(`${leftXs[0]} < x \\\\leq ${rightXs[0]}`)\r\n    domains.push(`${leftXs[1]} < x \\\\leq ${rightXs[1]}`)\r\n    domains.push(`${leftXs[2]} < x \\\\leq ${bYEP2}`)\r\n  } else {\r\n    leftXs.push(continuousX, endpoint2)\r\n    rightXs.push(continuousX, endpoint2)\r\n    domains.push(`${leftXs[0]} < x \\\\leq ${rightXs[0]}`)\r\n    domains.push(`${leftXs[1]} < x < ${rightXs[1]}`)\r\n    domains.push(`${leftXs[2]} \\\\leq x \\\\leq ${bYEP2}`)\r\n  }\r\n  rightXs.push(bYEP2)\r\n\r\n  // generate xypairs of points that functions should have\r\n  const xYPairs = [[], [], []]\r\n  xYPairs[1][0] = continuousX\r\n  xYPairs[1][1] = secondYAtContX\r\n\r\n  // generate middle function first\r\n  piecewiseFunctions[1] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 1)\r\n\r\n  // based on answer decide if endoint should be included\r\n  // find ep value from middle function\r\n  if (sqRtFunction === 1) {\r\n    // if sqrt function in the middle use nerdamer to keep sqrt\r\n    defaultEpY = nerdamer(piecewiseFunctions[1].f)\r\n      .sub(`x`, firstOrSecond === 0 ? endpoint1 : endpoint2)\r\n      .simplify()\r\n      .toString();\r\n  } else {\r\n    defaultEpY = math.evaluate(piecewiseFunctions[1].f,\r\n      { x: firstOrSecond === 0 ? endpoint1 : endpoint2 })\r\n  }\r\n\r\n  // based on value of default and answer, determine other ep value\r\n  if (Number.isNaN(Number(defaultEpY))) {\r\n    otherEpY = (ans === 2) ? getRandomWithExclusions(-7, 7, [0]) : defaultEpY\r\n  } else {\r\n    defaultEpY = Number(defaultEpY)\r\n    otherEpY = (ans === 2) ? getRandomWithExclusions(-7, 7, [defaultEpY, 0]) : defaultEpY\r\n  }\r\n\r\n  // populate xypairs with x-values\r\n  xYPairs[0][0] = rightXs[0]\r\n  xYPairs[2][0] = leftXs[2]\r\n\r\n  // determine y values based on root function position and firstorsecond\r\n  if (firstOrSecond === 1) {\r\n    if (functionTypes[2] === \"root\") {\r\n      xYPairs[0][1] = firstYAtContX\r\n      // corrner case where srF accidentally has same endpoint val\r\n      if ((ans === 0) && Math.round(math.evaluate(srF, { x: endpoint2 })) !== otherEpY) {\r\n        ans = 2\r\n      } else if (ans === 2 && Math.round(math.evaluate(srF, { x: endpoint2 })) === defaultEpY) {\r\n        ans = 0\r\n      }\r\n    } else {\r\n      xYPairs[0][1] = secondYAtContX\r\n      xYPairs[2][1] = otherEpY\r\n    }\r\n  } else {\r\n    if (functionTypes[0] === \"root\") {\r\n      xYPairs[2][1] = firstYAtContX\r\n      // corrner case where srF accidentally has same endpoint val\r\n      if ((ans === 0) && Math.round(math.evaluate(srF, { x: endpoint1 })) !== otherEpY) {\r\n        ans = 2\r\n      } else if (ans === 2 && Math.round(math.evaluate(srF, { x: endpoint1 })) === defaultEpY) {\r\n        ans = 0\r\n      }\r\n    } else {\r\n      xYPairs[0][1] = otherEpY\r\n      xYPairs[2][1] = secondYAtContX\r\n    }\r\n  }\r\n\r\n  // generate other fs based on values computed above\r\n  piecewiseFunctions[0] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 0)\r\n  piecewiseFunctions[2] = getFunctionHelper(srF, functionTypes, xYPairs, leftXs, rightXs, domains, 2)\r\n\r\n  // convert everything to latex\r\n  for (let i = 0; i < 3; i++) {\r\n    piecewiseFunctions[i].f = formatPolynomialToLatex(piecewiseFunctions[i].f)\r\n  }\r\n\r\n  const title = <></>\r\n\r\n  const question = <div className=\"flex vertical center medium-gap\">\r\n    <h2>\r\n      Is <Latex expression=\"f(x)\" /> continous on <Latex expression={`[${endpoint1}, ${endpoint2}]`} />?\r\n    </h2>\r\n    <Piecewise classes=\"large-font\" functions={piecewiseFunctions} title={`f(x)`} />\r\n  </div>\r\n\r\n  const hints: React.JSX.Element[] = [\r\n    <div>\r\n      <div className=\"flex vertical center medium-gap\">\r\n        <div>\r\n          Remember, we have 2 conditions to verify continuity on the closed interval <Latex expression={`[${endpoint1}, ${endpoint2}]`} /> for this function:\r\n        </div>\r\n        <Piecewise functions={piecewiseFunctions} title={`f(x)`} />\r\n      </div>\r\n      <div>\r\n        <ul className=\"text-start\">\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression=\"(a, b)\" />\r\n          </li>\r\n          <li>\r\n            <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to a^{\\\\footnotesize\\\\texttt{+}}} = f(a)`} /> and <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to b^{\\\\footnotesize\\\\texttt{-}}} = f(b)`} />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        Let's start with the first condition. First, it is worthwhile noting that at <Latex expression={`x = ${continuousX}`} />, there is a change in functions. Thus, for this condition, 3 things must be verified:\r\n      </div>\r\n      <div>\r\n        <ul className=\"text-start\">\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${continuousX})`} />\r\n          </li>\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous at <Latex expression={`x = ${continuousX}`} />\r\n          </li>\r\n          <li>\r\n            <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${continuousX}, ${endpoint2})`} />\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        For the first and third bullets, use the domains of the functions to determine whether they are continuous on those intervals.\r\n      </div>\r\n      <div>\r\n        For <Latex expression={`x = ${continuousX}`} />, do the process we learned in the last section to determine whether <Latex expression=\"f(x)\" /> is continuous at that point!\r\n      </div>\r\n    </div>,\r\n    <div className=\"flex vertical center medium-gap\">\r\n      <div>\r\n        If this verification fails, you automatically know <Latex expression=\"f(x)\" /> is not continuous on the given interval. If the verification passes, move on to the 2nd condition:\r\n      </div>\r\n      <div>\r\n        <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to a^{\\\\footnotesize\\\\texttt{+}}} = f(a)`} /> and <Latex classes=\"bold\" expression={`\\\\lim_{x \\\\to b^{\\\\footnotesize\\\\texttt{-}}} = f(b)`} />\r\n      </div>\r\n    </div>,\r\n    <div>\r\n      <div>\r\n        Basically, ensure the respective one-sided limits equal the respective function values. If either of these verifications fail, you know <Latex expression=\"f(x)\" /> is not continous on the interval. However, if both pass, both conditions of continuity on an interval have passed! Therefore, you know <Latex expression=\"f(x)\" /> is continous on the interval.\r\n      </div>\r\n    </div>\r\n  ]\r\n\r\n  const options: Option[] = [\r\n    {\r\n      component: <div>\r\n        Yes, <Latex expression=\"f(x)\" /> is continous on <Latex expression={`[${endpoint1}, ${endpoint2}]`} />.\r\n      </div>,\r\n      correct: ans === 0\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is not continuous at <Latex expression={`x = ${continuousX}`} />, so it is not continous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />.\r\n      </div>,\r\n      correct: ans === 1\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />, but <Latex expression={`\\\\lim_{x \\\\to ${endpoint1}^{\\\\footnotesize\\\\texttt{+}}} f(x) \\\\neq f(${endpoint1})`} />.\r\n      </div>,\r\n      correct: ans === 2 && firstOrSecond === 0\r\n    },\r\n    {\r\n      component: <div>\r\n        No, because <Latex expression=\"f(x)\" /> is continuous on <Latex expression={`(${endpoint1}, ${endpoint2})`} />, but <Latex expression={`\\\\lim_{x \\\\to ${endpoint2}^{\\\\footnotesize\\\\texttt{-}}} f(x) \\\\neq f(${endpoint2})`} />.\r\n      </div>,\r\n      correct: ans === 2 && firstOrSecond === 1\r\n    },\r\n  ]\r\n\r\n  return { title, question, type: 'mc', input: options, hints }\r\n}\r\n\r\n/**\r\n * Gets a sqrt function to use in above piecewise question\r\n * @param x x value at which there should be a squared y val on function\r\n * @returns sqrt function that has a wide enough domain\r\n */\r\nconst getSqrtFunction = (x: number) => {\r\n  let srF = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, getRandomNumber(1, 6) ** 2)\r\n  let roots = getRootsOfPolynomial(srF)\r\n\r\n  // keep generating function till it is valid for a wide enough domain\r\n  while (!roots[0].includes(\"i\") && !roots[1].includes(\"i\") &&\r\n    Number(roots[0]) !== Number(roots[1])) {\r\n    if (Math.floor(Number(roots[1])) - Math.ceil(Number(roots[0])) > 1) {\r\n      break;\r\n    }\r\n    srF = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, getRandomNumber(1, 6) ** 2)\r\n    roots = getRootsOfPolynomial(srF)\r\n  }\r\n\r\n  return srF\r\n}\r\n\r\n/**\r\n * Function generation helper method for above question\r\n * @param srF square root function\r\n * @param functions types of functions\r\n * @param xYPairs x, y pairs that function should have a point at\r\n * @param leftXs left domains\r\n * @param rightXs right domains\r\n * @param domains domain strings\r\n * @param i index to use in all arrays  \r\n * @returns piecewise function with generated function and domain\r\n */\r\nconst getFunctionHelper = (srF: string, functions: string[], xYPairs: Array<number>[],\r\n  leftXs: number[], rightXs: number[], domains: string[], i: number): PiecewiseFunction => {\r\n  // do srF in case the function is a root - otherwise, generate function normally\r\n  let f = srF;\r\n  if (functions[i] !== \"root\") {\r\n    f = generateFunction(functions[i], xYPairs[i][0], xYPairs[i][1], leftXs[i], rightXs[i])\r\n  }\r\n  return { f, domain: domains[i] }\r\n}\r\n\r\n/**\r\n * Generates specific function at (x, y)\r\n * @param type of function to generate\r\n * @param x value at which there should be a point\r\n * @param y value at which there should be a point\r\n * @param minValid x-value that function must be valid on\r\n * @param maxValid x-value that function must be valid on\r\n * @returns generated function string\r\n */\r\nconst generateFunction = (type: string, x: number, y: number | string,\r\n  minValid: number, maxValid: number) => {\r\n  if (type === \"ln\") {\r\n    const num: number = typeof y === \"string\" ? getRandomWithExclusions(-7, 7, [0]) : y\r\n    let node = getPolynomialFunctionWithPoint(getRandomNumber(1, 2), x, num)\r\n    if (typeof y === \"string\") {\r\n      // if y is a string (sqrt), use nerdamer to simplify\r\n      node = `${nerdamer(`simplify(${y}/${num})`)}(${node})`\r\n    }\r\n    return `log(e^(${node}))`\r\n  } else if (type === \"rat\") {\r\n    // get factors with xvals that are beyond min and max valid\r\n    const f1 = getStringFactorFromXval(maxValid + getRandomNumber(1, 2))\r\n    const f2 = getStringFactorFromXval(minValid - getRandomNumber(1, 2))\r\n\r\n    const bottomExpression = sortPolynomialByDegree(nerdamer(`${f1}${f2}`).expand());\r\n    const bottom = math.evaluate(bottomExpression, { x })\r\n\r\n    // use nerdamer to simplify in case y is a sqrt\r\n    const top = nerdamer(`simplify((${bottom})(${y}))`).toString()\r\n    return `${top}/(${bottomExpression})`\r\n  }\r\n}\r\n\r\nconst generateRandomQuestion = () => {\r\n  return piecewiseQuestion()\r\n}\r\n\r\nexport default generateRandomQuestion\r\n\r\n// if there are 3 functions\r\n// functions will be [(before ep1, ep1)], [(ep1, contX)], [(contX, beyond ep2)]\r\n// or [(before ep1, contX)], [(contX, ep2)], [(ep2, beyond ep2)]\r\n\r\n// if there are 2 functions\r\n// functions will be [(endpoint1, continuousX)] and the other one will be [(continousX, endpoint2)]\r\n// functions may or may not be continous at endpoint1 and endpoint2\r\n\r\n// question: is f(x) continuous on [(endpoint1, endpoint2)]\r\n\r\n// answer format\r\n// Yes (ans = 0)\r\n// No, because f(x) is not continuous at continousX, so it is not continous on (endpoint1, endpoint2) (ans = 1)\r\n// No, because f(x) is continuous on (endpoint1, endpoint2), but lim_{x \\\\to endpoint1^+} \\\\neq f(endpoint1) (ans = 2)\r\n// IF [endpoint1, endpoint2]:\r\n// No, because f(x) is continuous on (endpoint1, endpoint2), but lim_{x \\\\to endpoint2^-} \\\\neq f(endpoint2) (ans = 3)\r\n// ELSE IF ONLY 1 []\r\n// No, because lim_{x \\\\to endpoint2^+} \\\\neq f(endpoint2) (lim from diff side) (ans = 3)\r\n"],"names":["Piecewise","_ref","title","functions","display","classes","expression","setExpression","useState","useEffect","e","i","length","f","domain","_jsx","_Fragment","children","Latex","concat","nerdamer","require","getSqrtFunction","x","srF","getPolynomialFunctionWithPoint","getRandomNumber","roots","getRootsOfPolynomial","includes","Number","Math","floor","ceil","getFunctionHelper","xYPairs","leftXs","rightXs","domains","generateFunction","type","y","minValid","maxValid","num","getRandomWithExclusions","node","f1","getStringFactorFromXval","f2","bottomExpression","sortPolynomialByDegree","expand","bottom","math","top","toString","generateRandomQuestion","piecewiseQuestion","continuousX","firstOrSecond","endpoint1","endpoint2","sqRtFunction","getCoeffsOfPolynomial","rootNumbers","sort","a","b","b4EP1","bYEP2","ratFunction","lnFunction","functionTypes","ans","firstYAtContX","round","secondYAtContX","defaultEpY","otherEpY","piecewiseFunctions","push","sub","simplify","isNaN","formatPolynomialToLatex","question","_jsxs","className","hints","input","component","correct"],"sourceRoot":""}