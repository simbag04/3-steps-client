{"version":3,"file":"static/js/522.9c302252.chunk.js","mappings":"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","sources":["helpers/Latex.js","helpers/constants.js","helpers/functions.js","helpers/graph-helpers.js"],"sourcesContent":["/**\r\n * Latex component that uses katex to render math in latex font\r\n * Parameters: \r\n *  - classes: custom classes to be added to returned html\r\n *  - expression: math to be rendered as latex\r\n *  - inline: boolean value indicating whether latex should be rendered inline or block mode\r\n */\r\n\r\nimport 'katex/dist/katex.min.css';  // Import KaTeX styles\r\nimport { BlockMath, InlineMath } from 'react-katex';\r\n\r\nconst Latex = ({classes, expression, display}) => {\r\n  return (\r\n    <span className={classes}>\r\n      {!display ? \r\n      <InlineMath math={expression} /> :\r\n      <BlockMath math={expression} /> }\r\n    </span>\r\n  )\r\n}\r\n\r\nexport default Latex","const FAR_DIST = window.outerWidth < 800 ? 1.3 : 1;\r\nconst CLOSE_DIST = window.outerWidth < 800 ? 0.5 : 0.3;\r\nconst AXIS_OFFSET = window.outerWidth < 800 ? 0.4 : 0.3;\r\nconst GRAPH_SIZE = window.outerWidth < 800 ? 250 : 400;\r\nconst COLORS = ['red', 'green', 'blue', 'orange', 'purple'];\r\n\r\nexport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET, GRAPH_SIZE, COLORS }","import * as math from 'mathjs'\r\nimport { generateFunctionData } from './graph-helpers';\r\nconst nerdamer = require(\"nerdamer/all.min\")\r\n\r\n/**\r\n * Shuffles an array\r\n * @param {array} array array to be shuffled\r\n * @returns shuffled array\r\n */\r\nfunction shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1)); // Generate a random index from 0 to i\r\n\r\n    // Swap elements at i and j\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * generates a random number\r\n * @param {number} min minimum value of random number\r\n * @param {number} max maximum value of random number\r\n * @returns random number in the range [min, max]\r\n */\r\nfunction getRandomNumber(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\n/**\r\n * generates a random number with exclusions\r\n * @param {number} min minimum value of random number\r\n * @param {number} max maximum value of random number\r\n * @param {array} exclusions numbers to be excluded from generation\r\n * @returns random number in the range [min, max] excluding exclusions\r\n */\r\nfunction getRandomWithExclusions(min, max, exclusions) {\r\n  const validValues = [];\r\n  for (let i = min; i <= max; i++) {\r\n    if (!exclusions.includes(i)) {\r\n      validValues.push(i);\r\n    }\r\n  }\r\n\r\n  if (validValues.length === 0) {\r\n    return max;\r\n  }\r\n\r\n  const randomIndex = getRandomNumber(0, validValues.length - 1);\r\n  return validValues[randomIndex];\r\n}\r\n\r\n/**\r\n * @param {Number} n number of values to generate\r\n * @param {boolean} increasing true if values should be increasing, false if decreasing\r\n * @returns array of n ordered numbers \r\n */\r\nfunction generateOrderedValues(n, increasing) {\r\n  if (n <= 0) {\r\n    return [];\r\n  }\r\n\r\n  const values = [Math.floor(Math.random() * 10) + 1]; // Initialize with a random value\r\n\r\n  while (values.length < n) {\r\n    // generate a value greater than the last one\r\n    const nextDiff = getRandomNumber(1, 4) * (increasing ? 1 : -1);\r\n    const nextValue = values[values.length - 1] + nextDiff; \r\n    values.push(nextValue);\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\n/**\r\n * Compresses polynomial so it fits on 10 by 10 graph\r\n * @param {string} expression polynomial to compress\r\n * @param {number} max max (and min) value of local min/max\r\n * @param {array} values other values that should be within [-max, max]\r\n * @returns math.js node representing scaled polynomial\r\n */\r\nfunction compressPolynomial(expression, max, values) {\r\n  const node = math.parse(expression);\r\n\r\n  /// Makes all values within expression fit in graph range\r\n  // find most extreme value\r\n  let maxabs = Math.max(max, ...values);\r\n  for (let i = -11; i < 11; i += 0.01) {\r\n    maxabs = Math.max(Math.abs(node.evaluate({ x: i })), maxabs);\r\n  }\r\n\r\n  // scale to make graph fit\r\n  const scale = Math.ceil(maxabs / max);\r\n  const scaledNode = math.parse(`(1/${scale})(${expression})`);\r\n  return scaledNode;\r\n}\r\n\r\n/**\r\n * modifies expression to have whole number at a point\r\n * @param {node} node math.js node with current function\r\n * @returns modified node, x: modified math.js node that has a whole number value at x\r\n */\r\nfunction modifyForWholeNumber(node) {\r\n  const f = (x) => node.evaluate({ x });\r\n  let data = generateFunctionData(f, -11, 11);\r\n\r\n  // filter out values where y is > 7 or < -7, x is > 8 or < -8\r\n  data = data.filter(d => Math.abs(d.y) < 7 && Math.abs(d.x) < 8);\r\n\r\n  // random x value in domain\r\n  const minx = Math.ceil(data[0].x);\r\n  const maxx = Math.floor(data[data.length - 1].x);\r\n\r\n  const x = getRandomWithExclusions(minx, maxx, [-1, 0, 1]);\r\n  const y = f(x);\r\n\r\n  // find constant by which to move graph up or down to get integer y\r\n  let move;\r\n  if (Math.round(y) < 0) {\r\n    move = Math.min(-2, Math.round(y)) - y; // y must be <= -2\r\n  } else {\r\n    move = Math.max(2, Math.round(y)) - y; // int y must be >= 2\r\n  }\r\n\r\n  let expression = `(${node.toString()} + ${move})`\r\n  const modifiedNode = math.parse(expression);\r\n  return { node: modifiedNode, x };\r\n}\r\n\r\n/**\r\n * Generates ready to graph random polynomial function\r\n * @param {number} degree degree of polynomial to be generated\r\n * @returns ready to graph polynomial function with integer point at x\r\n */\r\nfunction generateRandomPolynomial(degree) {\r\n  const expression = getPolynomialFunction(degree);\r\n  const scaledNode = compressPolynomial(expression, 9, []);\r\n  return modifyForWholeNumber(scaledNode);\r\n}\r\n\r\n/**\r\n * generates random polynomial function with random whole number coefficients \r\n * @param {number} degree degree of polynomial to generate\r\n * @returns random polynomial function with random coefficients\r\n */\r\nfunction getPolynomialFunction(degree) {\r\n  const coefficients = [];\r\n  for (let i = 0; i <= degree; i++) {\r\n    coefficients.push(getRandomNumber(-5, 5));\r\n  }\r\n\r\n  let terms = coefficients.map((coef, exp) => {\r\n    if (exp === 0) {\r\n      return coef === 0 ? \"\" : `(${coef})`;\r\n    } else if (exp === 1) {\r\n      return coef === 0 ? \"\" : `(${coef}*x)`;\r\n    } else {\r\n      return coef === 0 ? \"\" : `(${coef}*(x^${exp}))`;\r\n    }\r\n  });\r\n\r\n  terms = terms.filter(t => t !== \"\");\r\n\r\n  const expression = terms.reverse().join(' + ').replace(/\\s+/g, '');\r\n  return expression;\r\n}\r\n\r\n/**\r\n * Generates a random polynomial that passes through a point and fits on 10 by 10 graph\r\n * @param {number} degree degree of polynomial to generate\r\n * @param {number} x x value of point\r\n * @param {number} y y value of point\r\n * @returns math.js node representing polynomial expression\r\n */\r\nfunction generateRandomPolynomialWithPoint(degree, x, y) {\r\n  // generate polynomial\r\n  let expression = getPolynomialFunction(degree);\r\n  let node = math.parse(expression);\r\n\r\n  // initialize variables\r\n  let max = 9;\r\n  node = compressPolynomial(node.toString(), max, []);\r\n  let yval = node.evaluate({ x });\r\n  let move = y - yval;\r\n\r\n  // compress polynomial enough that constant by which graph moves up or down is still within [-10, 10]\r\n  while (Math.abs(move) > 10 - max) {\r\n    max--;\r\n    node = compressPolynomial(node.toString(), max, [Math.abs(yval)]);\r\n    yval = node.evaluate({ x });\r\n    move = y - yval;\r\n  }\r\n  expression = `(${node.toString()} + ${move})`\r\n  const modifiedNode = math.parse(expression);\r\n  return modifiedNode;\r\n}\r\n\r\n/**\r\n * \r\n * @param {String} polynomial string with a polynomial\r\n * @returns polynomial sorted in order of degree\r\n */\r\nfunction sortPolynomialByDegree (polynomial) {\r\n  // get coefficients with nerdamer\r\n  const coefficients = nerdamer.coeffs(polynomial, 'x');\r\n  let ans = \"\";\r\n  const coeffs = [];\r\n  coefficients.each(function(e) {\r\n    coeffs.push(nerdamer(e).toString());\r\n  })\r\n\r\n  // build expression\r\n  for (let i = coeffs.length - 1; i >= 0; i--) {\r\n    if (coeffs[i] === \"0\") continue; // skip 0 terms\r\n\r\n    // add \"+\" before positive coefficient terms\r\n    if (i !== coeffs.length - 1) {\r\n      if (Number(coeffs[i]) > 0) {\r\n        ans += \"+\"\r\n      } \r\n    }\r\n\r\n    if (coeffs[i] !== \"1\") {\r\n      ans += coeffs[i];\r\n    }\r\n\r\n    if (i > 1) {\r\n      ans += `x^${i}`;\r\n    } else if (i === 1) {\r\n      ans += 'x';\r\n    }\r\n  }\r\n  return ans;\r\n}\r\n\r\n/**\r\n * \r\n * @param {String} xval xvalue from which to create factor\r\n * @returns String in form (x - p), where p is the xval\r\n */\r\nfunction getStringFactorFromXval (xval) {\r\n  const x = Number(xval);\r\n  if (x < 0) {\r\n    return `(x + ${Math.abs(x)})`\r\n  } else if (x > 0) {\r\n    return `(x - ${x})`\r\n  } else {\r\n    return `(x)`\r\n  }\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} points array of 3 points ({x, y}) to fit quadratic to\r\n * @returns math.js node representing polynomial expression\r\n */\r\nfunction fitPointsToQuadratic(points) {\r\n  // Ensure we have at least 3 points\r\n  if (points.length < 3) {\r\n    console.error('At least 3 points are required for quadratic regression.');\r\n    return null;\r\n  }\r\n\r\n  // get points\r\n  const x1 = points[0].x;\r\n  const y1 = points[0].y;\r\n  const x2 = points[1].x;\r\n  const y2 = points[1].y;\r\n  const x3 = points[2].x;\r\n  const y3 = points[2].y;\r\n\r\n  // formula\r\n  const det = (x1 - x2) * (x1 - x3) * (x2 - x3);\r\n  const a = ((x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / det);\r\n  const b = ((x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / det);\r\n  const c = ((x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / det);\r\n\r\n  // Return math.js node\r\n  return math.parse(`${a === 0 ? `` : `${a}x^2`} + ${b === 0 ? `` : `${b}x`} + ${c}`)\r\n}\r\n\r\nexport { generateRandomPolynomial, getRandomNumber, getRandomWithExclusions, generateOrderedValues, shuffleArray, generateRandomPolynomialWithPoint, fitPointsToQuadratic, sortPolynomialByDegree, getStringFactorFromXval }","import * as d3 from 'd3';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET } from \"./constants\";\r\n\r\n/**\r\n * generates graphing data for mathematical function\r\n * @param {function} f function for which to generate data\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @returns array of data with generated values\r\n */\r\nconst generateFunctionData = (f, min, max) => {\r\n  let data = [];\r\n\r\n  for (let i = min; i <= max; i += 0.01) {\r\n    const x = i;\r\n    const y = f(i)\r\n    data.push({ x, y });\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * appends graph of a mathematical function on an svg\r\n * @param {svg} svg element on which to draw function graph\r\n * @param {function} f function to graph \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {color} color color of graph\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @param {string} classes custom string of classes to include in function path/arrows\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @param {boolean} leftArrow whether there should be an arrow on the left of the graph\r\n * @param {boolean} rightArrow whether there should be an arrow on the right of the graph\r\n * @param {String} type can be \"asymptotic\"\r\n * @returns data that was used to graph function, id of svg path of function\r\n */\r\nconst createFunctionGraph = (svg, f, width, height, color, xScale, yScale, classes, min, max, leftArrow, rightArrow, type) => {\r\n  let data = generateFunctionData(f, min, max); // generate data\r\n\r\n  // filter data\r\n  data = data.filter((d) => d.x > Math.min(xScale.invert(0), max) &&\r\n    d.x < Math.max(xScale.invert(width), min) &&\r\n    d.y > yScale.invert(height) &&\r\n    d.y < yScale.invert(0))\r\n\r\n  if (type === \"asymptotic\") {\r\n    // make left part of graph go to edge\r\n    if (min > xScale.invert(0)) {\r\n      // get data point of intersection with top/bottom of graph\r\n      const y = data[0].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, min + 0.00001, data[0].x, 0.01);\r\n      if (d) data.unshift({x: d, y: f(d)}); // add point to beginning of data\r\n    }\r\n\r\n    // make right part of graph go to edge\r\n    if (max < xScale.invert(width)) {\r\n      // data point of intersection with top/bottom\r\n      const y = data[data.length - 1].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, data[data.length - 1].x, max - 0.00001, 0.01);\r\n      if (d) data.push({x: d, y: f(d)}); // add point to end of data\r\n    }\r\n  }\r\n\r\n  const line = d3.line()\r\n    .x(d => xScale(d.x))\r\n    .y(d => yScale(d.y))\r\n\r\n  // arrow markers for graph\r\n  const markerSize = 5;\r\n  const name = 'function-arrow'\r\n  createArrowMarker(name, svg, markerSize, color, classes)\r\n\r\n  // create graph\r\n  const id = uuidv4();\r\n  svg.append('path')\r\n    .datum(data)\r\n    .attr('data-uuid', id)\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('fill', 'none')\r\n    .attr('stroke', color)\r\n    .attr('stroke-width', 2)\r\n    .attr('marker-end', rightArrow ? `url(#${name})` : null)\r\n    .attr('marker-start', leftArrow ? `url(#${name})` : null)\r\n    .attr('d', line);\r\n\r\n  svg.select(\".tick-text\").raise(); // raise tickmarks on top\r\n\r\n  return { data, id };\r\n}\r\n\r\n/**\r\n * \r\n * @param {function} func for which to find intersections\r\n * @param {number} y of intersection point\r\n * @param {number} xMin of domain\r\n * @param {number} xMax of domain\r\n * @param {number} tolerance for how far away ans can be from y\r\n * @returns \r\n */\r\nfunction findIntersections(func, y, xMin, xMax, tolerance) {\r\n  var a = xMin;\r\n  var b = xMax;\r\n  \r\n  // binary search\r\n  while (b - a > 0.00001) {\r\n    var xMid = (a + b) / 2;\r\n    var yMid = func(xMid);\r\n    \r\n    if (y > 0 && yMid <= y && y - yMid < tolerance) {\r\n      return xMid;\r\n    }\r\n    if (y < 0 && yMid >= y && yMid - y < tolerance) {\r\n      return xMid;\r\n    }\r\n    \r\n    // update based on graph behavior\r\n    if (func(xMin) < func(xMax) && yMid < y) {\r\n      // increasing graph, y too low\r\n      a = xMid;\r\n    } else if (func(xMin) < func(xMax)) {\r\n      // increasing graph, y too high\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax) && yMid < y) {\r\n      // decreasing graph, y too low\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax)) {\r\n      // decreasing graph, y too high\r\n      a = xMid;\r\n    }\r\n  }\r\n\r\n  return (a + b) / 2; // nothing found so get midpoint\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg on which to draw function graph\r\n * @param {Array} functions to graph, each has the f, min/max domain, and includesLeft/includesRight, which indicates whether min/max are included or not\r\n * @param {int} width of svg\r\n * @param {int} height of svg\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @returns {Array} array of all data and ids of function graphs\r\n */\r\nconst createMultipleFunctionsGraph = (svg, functions, width, height, xScale, yScale) => {\r\n  const dataArray = [];\r\n\r\n  for (let i = 0; i < functions.length; i++) {\r\n    // add graph for each function\r\n    const func = functions[i];\r\n    const { data, id } = createFunctionGraph(svg, func.f, width, height, null, xScale, yScale, func.classes, func.min, func.max, func.leftArrow, func.rightArrow, func.type);\r\n\r\n    dataArray[dataArray.length] = { data, id }; // save return values\r\n\r\n    // append circles as holes/points if needed\r\n    if (func.leftCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeLeft ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.min))\r\n        .attr('cy', yScale(func.f(func.min)))\r\n        .attr('r', 3)\r\n    }\r\n\r\n    if (func.rightCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeRight ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.max))\r\n        .attr('cy', yScale(func.f(func.max)))\r\n        .attr('r', 3)\r\n    }\r\n  }\r\n\r\n  return { dataArray }\r\n}\r\n\r\n/**\r\n * creates -10 by 10 blank canvas on top of which graphs can be drawn \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {Ref} svgRef reference to svg where graph should be drawn\r\n * @param {number} textSize size of text of graph labels\r\n * @returns width, height, xscale, and yscale of graph\r\n */\r\nconst createBlankCanvas = (width, height, svgRef, textSize) => {\r\n  const numCells = 20;\r\n  const half = (width / 2) / numCells;\r\n  const color = \"#707070\"\r\n  const size = 5;\r\n\r\n  const svg = d3.select(svgRef.current);\r\n  svg.selectAll(\"*\").remove();\r\n\r\n  svg\r\n    .attr('width', width)\r\n    .attr('height', height)\r\n\r\n  // scales\r\n  const xScale = d3.scaleLinear()\r\n    .domain([-1 * numCells / 2, numCells / 2])\r\n    .range([half, width - half]);\r\n\r\n  const yScale = d3.scaleLinear()\r\n    .domain([-1 * numCells / 2, numCells / 2])\r\n    .range([-1 * half + height, half]);\r\n\r\n  // build grid lines\r\n  svg\r\n    .selectAll(\".x-grid-line\")\r\n    .data(d3.range(-1 * numCells / 2, numCells / 2 + 1))\r\n    .enter().append(\"line\")\r\n    .attr(\"class\", \"x-grid-line\")\r\n    .attr(\"x1\", d => xScale(d))\r\n    .attr(\"x2\", d => xScale(d))\r\n    .attr(\"y1\", 0)\r\n    .attr(\"y2\", height)\r\n    .attr(\"stroke\", \"lightgray\");\r\n\r\n  svg\r\n    .selectAll(\".y-grid-line\")\r\n    .data(d3.range(-1 * numCells / 2, numCells / 2 + 1))\r\n    .enter().append(\"line\")\r\n    .attr(\"class\", \"y-grid-line\")\r\n    .attr(\"x1\", 0)\r\n    .attr(\"x2\", width)\r\n    .attr(\"y1\", d => yScale(d))\r\n    .attr(\"y2\", d => yScale(d))\r\n    .attr(\"stroke\", \"lightgray\");\r\n\r\n  // build tick marks on axes\r\n  const tickMarks = svg.append('g')\r\n    .attr('class', 'tick-marks');\r\n\r\n  const tickText = svg.append('g')\r\n    .attr('class', 'tick-text')\r\n\r\n  // add marks and text to xaxis\r\n  xScale.ticks().forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(tick))\r\n      .attr(\"x2\", xScale(tick))\r\n      .attr(\"y1\", yScale(0) - 4)\r\n      .attr(\"y2\", yScale(0) + 4)\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(tick) + (tick < 0 ? 1.5 : -1.5))\r\n      .attr(\"y\", yScale(0) + 3)\r\n      .attr('alignment-baseline', 'hanging')\r\n      .attr('text-anchor', tick < 0 ? 'start' : 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(tick)\r\n  })\r\n\r\n  // add marks and text to y axis\r\n  yScale.ticks().forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(0) - 4)\r\n      .attr(\"x2\", xScale(0) + 4)\r\n      .attr(\"y1\", yScale(tick))\r\n      .attr(\"y2\", yScale(tick))\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(0) - 3)\r\n      .attr(\"y\", yScale(tick) + (tick < 0 ? -1.5 : 1.5))\r\n      .attr('alignment-baseline', tick < 0 ? 'baseline' : 'hanging')\r\n      .attr('text-anchor', 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(tick)\r\n  })\r\n\r\n  // draw actual x and y axes\r\n  const name = \"axes-arrow\"\r\n  createArrowMarker(name, svg, size, color);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", 0)\r\n    .attr(\"x2\", width)\r\n    .attr(\"y1\", yScale(0))\r\n    .attr(\"y2\", yScale(0))\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", xScale(0))\r\n    .attr(\"x2\", xScale(0))\r\n    .attr(\"y1\", height)\r\n    .attr(\"y2\", 0)\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  return { width, height, xScale, yScale }\r\n};\r\n\r\n/**\r\n * generates custom arrow marker to be used in graphs of functions\r\n * @param {string} name identifier name of arrow marker being generated\r\n * @param {svg} svg svg where marker should be appended\r\n * @param {number} size size of marker\r\n * @param {string} color color of marker\r\n * @param {string} classes custom classes to be added to marker\r\n */\r\nfunction createArrowMarker(name, svg, size, color, classes) {\r\n  svg.append(\"defs\").append(\"marker\")\r\n    .attr(\"id\", name)\r\n    .attr('class', 'fill ' + classes)\r\n    .attr(\"refX\", size)\r\n    .attr(\"refY\", size / 2)\r\n    .attr(\"markerWidth\", size)\r\n    .attr(\"markerHeight\", size)\r\n    .attr(\"orient\", \"auto-start-reverse\")\r\n    .attr('fill', color)\r\n    .append(\"path\")\r\n    .attr(\"d\", `M0,0 V${size} Q${size * 2},${size / 2} 0,0`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg in which to append limit line\r\n * @param {function} line function for 'd' attribute of path\r\n * @param {number} x1 x1 of line\r\n * @param {number} x2 x2 of line\r\n * @param {number} y1 y1 of line\r\n * @param {number} y2 y2 of line\r\n * @param {string} name of arrow markers on line\r\n * @param {string} classes custom classes o add to generated arrow\r\n */\r\nfunction createLimitLine(svg, line, x1, x2, y1, y2, name, classes) {\r\n  // check if arrow marker exists\r\n  if (d3.select(`#${name}`).empty()) {\r\n    createArrowMarker(name, svg, 4, null, classes)\r\n  }\r\n\r\n  // add limit line\r\n  svg.append('path')\r\n    .datum([{ x: x1, y: y1 }, { x: x2, y: y2 }])\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('stroke-width', 1)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('d', line)\r\n}\r\n\r\n/**\r\n * finds hypotenuse frm width/height of triangle\r\n * @param {number} x width\r\n * @param {number} y height\r\n * @returns hypotenuse of triangle formed with width/height\r\n */\r\nfunction findHypotenusefromSlope(x, y) {\r\n  return Math.sqrt(((x) ** 2) + ((y) ** 2))\r\n}\r\n\r\n/**\r\n * converts points from svg scale to normal -10 to 10 x/y\r\n * @param {object} far far point\r\n * @param {object} close close point\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @returns points object with converted x/y values\r\n */\r\nfunction convertScale(far, close, xScale, yScale) {\r\n  const farx = xScale.invert(far.x)\r\n  const closex = xScale.invert(close.x)\r\n  const fary = yScale.invert(far.y)\r\n  const closey = yScale.invert(close.y)\r\n  return { farx, closex, fary, closey }\r\n}\r\n\r\n/**\r\n * perpendicular slope from points\r\n * @param {object} points object representing points from which to compute slope\r\n * @returns perpendicular slope from points\r\n */\r\nfunction findSlope(points) {\r\n  let ans = (-1 * (points.farx - points.closex)) / (points.fary - points.closey)\r\n  return ans;\r\n}\r\n\r\n/**\r\n * Finds offsets of lines/text from function line\r\n * @param {object} points object representing points from which line needs to be offset\r\n * @param {number} axisOffset how much line should be offset\r\n * @returns x, y representing by how much lines need to move in each direction\r\n */\r\nfunction findOffsets(points, axisOffset) {\r\n  let slope = findSlope(points)\r\n  const hyp = findHypotenusefromSlope(1, slope);\r\n  let scale = -1 * axisOffset / hyp;\r\n  if (slope > 0) scale *= -1\r\n  const x = scale;\r\n  const y = (scale) * slope;\r\n\r\n  return { x, y }\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {svg} svg on which to append lines\r\n * @param {Element} functionLine line for function\r\n * @param {int} pathLength length of path up till point\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @param {function} line function that creates 'd' attribute in svg path\r\n * @param {String} fColor color of function\r\n * @param {boolean} right true if the limit line to be drawn should be from the right, false if left\r\n * @param {String} markerName custom name of arrow marker\r\n * @returns points of the line in svg scale\r\n */\r\n\r\nfunction createFunctionLimitLine(svg, functionLine, pathLength, xScale, yScale, line, fColor, right, markerName) {\r\n\r\n  // modify lengths based on if the arrow is from the left or the right\r\n  let farDistLength = xScale(FAR_DIST) - xScale(0);\r\n  farDistLength = right ? farDistLength : (-1 * farDistLength);\r\n  let closeDistLength = xScale(CLOSE_DIST) - xScale(0);\r\n  closeDistLength = right ? closeDistLength : (-1 * closeDistLength)\r\n\r\n  // arrow from the left\r\n  const farPoint = functionLine.getPointAtLength(pathLength + farDistLength)\r\n  const closePoint = functionLine.getPointAtLength(pathLength + closeDistLength)\r\n  const pointsOne = convertScale(farPoint, closePoint, xScale, yScale)\r\n  const offsetsOne = findOffsets(pointsOne, AXIS_OFFSET);\r\n\r\n  if (isNaN(offsetsOne.y)) offsetsOne.y = AXIS_OFFSET;\r\n\r\n  createLimitLine(svg, line,\r\n    pointsOne.farx + offsetsOne.x,\r\n    pointsOne.closex + offsetsOne.x,\r\n    pointsOne.fary + offsetsOne.y,\r\n    pointsOne.closey + offsetsOne.y,\r\n    markerName ? markerName : 'f-limits', fColor)\r\n\r\n  return { closePoint, farPoint }\r\n}\r\n\r\nexport { createFunctionGraph, createBlankCanvas, createArrowMarker, generateFunctionData, createLimitLine, findHypotenusefromSlope, convertScale, findSlope, findOffsets, createMultipleFunctionsGraph, createFunctionLimitLine }\r\n"],"names":["_ref","classes","expression","display","_jsx","className","children","BlockMath","math","InlineMath","FAR_DIST","window","outerWidth","CLOSE_DIST","AXIS_OFFSET","GRAPH_SIZE","COLORS","nerdamer","require","shuffleArray","array","i","length","j","Math","floor","random","getRandomNumber","min","max","getRandomWithExclusions","exclusions","validValues","includes","push","generateOrderedValues","n","increasing","values","nextDiff","nextValue","compressPolynomial","node","maxabs","apply","concat","_toConsumableArray","abs","evaluate","x","scale","ceil","generateRandomPolynomial","degree","f","data","generateFunctionData","filter","d","y","move","round","toString","modifyForWholeNumber","getPolynomialFunction","coefficients","terms","map","coef","exp","t","reverse","join","replace","generateRandomPolynomialWithPoint","yval","sortPolynomialByDegree","polynomial","coeffs","ans","each","e","Number","getStringFactorFromXval","xval","fitPointsToQuadratic","points","console","error","x1","y1","x2","y2","x3","y3","det","a","b","c","createFunctionGraph","svg","width","height","color","xScale","yScale","leftArrow","rightArrow","type","invert","findIntersections","unshift","line","d3","name","createArrowMarker","id","uuidv4","append","datum","attr","select","raise","func","xMin","xMax","tolerance","xMid","yMid","createMultipleFunctionsGraph","functions","dataArray","_createFunctionGraph","leftCircle","includeLeft","rightCircle","includeRight","createBlankCanvas","svgRef","textSize","numCells","half","current","selectAll","remove","domain","range","enter","tickMarks","tickText","ticks","forEach","tick","style","text","size","createLimitLine","empty","convertScale","far","close","farx","closex","fary","closey","findOffsets","axisOffset","slope","findSlope","hyp","sqrt","pow","findHypotenusefromSlope","createFunctionLimitLine","functionLine","pathLength","fColor","right","markerName","farDistLength","closeDistLength","farPoint","getPointAtLength","closePoint","pointsOne","offsetsOne","isNaN"],"sourceRoot":""}