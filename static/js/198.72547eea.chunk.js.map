{"version":3,"file":"static/js/198.72547eea.chunk.js","mappings":"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","sources":["helpers/constants.tsx","helpers/expression-generators.js","helpers/functions.ts","helpers/graph-helpers.js"],"sourcesContent":["const FAR_DIST = window.outerWidth < 800 ? 1.3 : 1;\r\nconst CLOSE_DIST = window.outerWidth < 800 ? 0.5 : 0.3;\r\nconst AXIS_OFFSET = window.outerWidth < 800 ? 0.4 : 0.3;\r\nconst GRAPH_SIZE = window.outerWidth < 800 ? 250 : 400;\r\nconst COLORS = ['red', 'green', 'blue', 'orange', 'purple'];\r\n\r\nexport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET, GRAPH_SIZE, COLORS }","import * as math from 'mathjs'\r\nimport { generateFunctionData } from './graph-helpers';\r\nimport { getRandomWithExclusions, getRandomNumber, convertArrayToObject, findLCM, convertToDecimal } from './functions';\r\n\r\n/**\r\n * Compresses polynomial so it fits on 10 by 10 graph\r\n * @param {string} expression polynomial to compress\r\n * @param {number} max max (and min) value of local min/max\r\n * @param {array} values other values that should be within [-max, max]\r\n * @returns math.js node representing scaled polynomial\r\n */\r\nfunction compressPolynomial(expression, max, values) {\r\n  const node = math.parse(expression);\r\n\r\n  /// Makes all values within expression fit in graph range\r\n  // find most extreme value\r\n  let maxabs = Math.max(max, ...values);\r\n  for (let i = -11; i < 11; i += 0.01) {\r\n    maxabs = Math.max(Math.abs(node.evaluate({ x: i })), maxabs);\r\n  }\r\n\r\n  // scale to make graph fit\r\n  const scale = Math.ceil(maxabs / max);\r\n  const scaledNode = math.parse(`(1/${scale})(${expression})`);\r\n  return scaledNode;\r\n}\r\n\r\n/**\r\n * modifies expression to have whole number at a point\r\n * @param {node} node math.js node with current function\r\n * @returns modified node, x: modified math.js node that has a whole number value at x\r\n */\r\nfunction modifyForWholeNumber(node) {\r\n  const f = (x) => node.evaluate({ x });\r\n  let data = generateFunctionData(f, -11, 11);\r\n\r\n  // filter out values where y is > 7 or < -7, x is > 8 or < -8\r\n  data = data.filter(d => Math.abs(d.y) < 7 && Math.abs(d.x) < 8);\r\n\r\n  // random x value in domain\r\n  const minx = Math.ceil(data[0].x);\r\n  const maxx = Math.floor(data[data.length - 1].x);\r\n\r\n  const x = getRandomWithExclusions(minx, maxx, [-1, 0, 1]);\r\n  const y = f(x);\r\n\r\n  // find constant by which to move graph up or down to get integer y\r\n  let move;\r\n  if (Math.round(y) < 0) {\r\n    move = Math.min(-2, Math.round(y)) - y; // y must be <= -2\r\n  } else {\r\n    move = Math.max(2, Math.round(y)) - y; // int y must be >= 2\r\n  }\r\n\r\n  let expression = `(${node.toString()} + ${move})`\r\n  const modifiedNode = math.parse(expression);\r\n  return { node: modifiedNode, x };\r\n}\r\n\r\n/**\r\n * Generates ready to graph random polynomial function\r\n * @param {number} degree degree of polynomial to be generated\r\n * @returns ready to graph polynomial function with integer point at x\r\n */\r\nfunction generateRandomPolynomial(degree) {\r\n  const expression = getPolynomialFunction(degree);\r\n  const scaledNode = compressPolynomial(expression, 9, []);\r\n  return modifyForWholeNumber(scaledNode);\r\n}\r\n\r\n/**\r\n * generates random polynomial function with random whole number coefficients \r\n * @param {number} degree degree of polynomial to generate\r\n * @param {boolean} skipConstant boolean whether to not generate constant \r\n * @param {boolean} [guaranteedTermAtDegree=false] whether there must be a term at the specified degree (eg. if degree is 2, there must be an x^2 term)\r\n * @returns random polynomial function with random coefficients\r\n */\r\nfunction getPolynomialFunction(degree, skipConstant = false, guaranteedTermAtDegree = false) {\r\n  const coefficients = [];\r\n  for (let i = 0; i <= degree; i++) {\r\n    if (guaranteedTermAtDegree && degree === i) {\r\n      coefficients.push(getRandomWithExclusions(-5, 5, [0]));\r\n    } else {\r\n      coefficients.push(getRandomNumber(-5, 5));\r\n    }\r\n  }\r\n\r\n  let terms = coefficients.map((coef, exp) => {\r\n    if (exp === 0) {\r\n      if (skipConstant || coef === 0) return \"\";\r\n      return coef < 0 ? `${coef}` : `+${coef}`;\r\n    } else if (exp === 1) {\r\n      if (coef === 0) return \"\";\r\n      let t = `${Math.abs(coef) === 1 ? \"\" : `${Math.abs(coef)}*`}x`\r\n      return coef < 0 ? `-${t}` : `+${t}`;\r\n    } else {\r\n      if (coef === 0) return \"\";\r\n      let t = `${coef === 1 ? \"\" : coef === -1 ? \"-\" : `${Math.abs(coef)}*`}x^${exp}`\r\n      return (coef < 0 || exp === coefficients.length - 1) ? `-${t}` : `+${t}`;\r\n    }\r\n  });\r\n\r\n  terms = terms.filter(t => t !== \"\");\r\n\r\n  const expression = terms.reverse().join('').replace(/\\s+/g, '');\r\n  if (expression.length < 2) return '(2*x)';\r\n  return expression;\r\n}\r\n\r\n/**\r\n * generates polynomial with point (not necessarily for a graph)\r\n * @param {Number} degree of polynomial\r\n * @param {Number} x value of point\r\n * @param {Number} y value of point\r\n * @param {boolean} [guaranteedTermAtDegree=false] whether there must be a term at the specified degree (eg. if degree is 2, there must be an x^2 term)\r\n * @returns string expression of polynomial\r\n */\r\nfunction getPolynomialFunctionWithPoint(degree, x, y, guaranteedTermAtDegree = false) {\r\n  let expression = getPolynomialFunction(degree, true, guaranteedTermAtDegree);\r\n\r\n  // add constant to function to make (x, y) on graph\r\n  let currVal = math.evaluate(expression, { x });\r\n  const diff = y - Math.round(currVal);\r\n  expression = `${expression} ${diff < 0 ? diff : diff > 0 ? `+ ${diff}` : ''}`;\r\n  return expression;\r\n}\r\n\r\n/**\r\n * Generates a random polynomial that passes through a point and fits on 10 by 10 graph\r\n * @param {number} degree degree of polynomial to generate\r\n * @param {number} x x value of point\r\n * @param {number} y y value of point\r\n * @returns math.js node representing polynomial expression\r\n */\r\nfunction generateRandomPolynomialWithPoint(degree, x, y) {\r\n  // generate polynomial\r\n  let expression = getPolynomialFunction(degree);\r\n  let node = math.parse(expression);\r\n\r\n  // initialize variables\r\n  let max = 9;\r\n  node = compressPolynomial(node.toString(), max, []);\r\n  let yval = node.evaluate({ x });\r\n  let move = y - yval;\r\n\r\n  // compress polynomial enough that constant by which graph moves up or down is still within [-10, 10]\r\n  while (Math.abs(move) > 10 - max) {\r\n    max--;\r\n    node = compressPolynomial(node.toString(), max, [Math.abs(yval)]);\r\n    yval = node.evaluate({ x });\r\n    move = y - yval;\r\n  }\r\n  expression = `(${node.toString()} + ${move})`\r\n  const modifiedNode = math.parse(expression);\r\n  return modifiedNode;\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {Array} points array of 3 points ({x, y}) to fit quadratic to\r\n * @returns math.js node representing polynomial expression\r\n */\r\nfunction fitPointsToQuadratic(points) {\r\n  // Ensure we have at least 3 points\r\n  if (points.length < 3) {\r\n    console.error('At least 3 points are required for quadratic regression.');\r\n    return null;\r\n  }\r\n\r\n  // get points\r\n  const x1 = points[0].x;\r\n  const y1 = points[0].y;\r\n  const x2 = points[1].x;\r\n  const y2 = points[1].y;\r\n  const x3 = points[2].x;\r\n  const y3 = points[2].y;\r\n\r\n  // formula\r\n  const det = (x1 - x2) * (x1 - x3) * (x2 - x3);\r\n  const a = ((x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / det);\r\n  const b = ((x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / det);\r\n  const c = ((x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / det);\r\n\r\n  // Return math.js node\r\n  return math.parse(`${a === 0 ? `` : `${a}x^2`} + ${b === 0 ? `` : `${b}x`} + ${c}`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} points array of 3 points ({x, y}) to fit quadratic to\r\n * @returns math.js node representing polynomial expression with fractional coefficients\r\n */\r\nfunction fitPointsToQuadraticFractions(points) {\r\n  // Ensure we have at least 3 points\r\n  if (points.length < 3) {\r\n    console.error('At least 3 points are required for quadratic regression.');\r\n    return null;\r\n  }\r\n\r\n  // get points\r\n  const x1 = points[0].x;\r\n  const y1 = points[0].y;\r\n  const x2 = points[1].x;\r\n  const y2 = points[1].y;\r\n  const x3 = points[2].x;\r\n  const y3 = points[2].y;\r\n\r\n  // Calculating coefficients a, b, and c\r\n  const denominatorA = (x1 - x2) * (x1 - x3);\r\n  const denominatorB = (x2 - x1) * (x2 - x3);\r\n  const denominatorC = (x3 - x1) * (x3 - x2);\r\n\r\n  const a = math.string(math.simplify(`(${y1} / ${denominatorA}) + (${y2} / ${denominatorB}) + (${y3} / ${denominatorC})`));\r\n\r\n  const b = math.string(math.simplify(`-(\r\n    (${y1 * (x2 + x3)} / ${denominatorA}) +\r\n    (${y2 * (x1 + x3)} / ${denominatorB}) +\r\n    (${y3 * (x1 + x2)} / ${denominatorC})\r\n  )`));\r\n\r\n  const c = math.string(math.simplify(`(\r\n    (${y1 * x2 * x3} / ${denominatorA}) +\r\n    (${y2 * x1 * x3} / ${denominatorB}) +\r\n    (${y3 * x1 * x2} / ${denominatorC})\r\n  )`));\r\n  // Return math.js node\r\n  return createPolynomialFromCoefficients(a, b, c)\r\n}\r\n\r\n/**\r\n * creates formatted polynomial math.js node from potentially fractional coefficients\r\n * @param {Number} a coefficient of quadratic\r\n * @param {Number} b coefficient of quadratic\r\n * @param {Number} c coefficient of quadratic\r\n * @returns math.js formatted polynomial node\r\n */\r\nconst createPolynomialFromCoefficients = (a, b, c) => {\r\n  const newA = Number(convertToDecimal(a))\r\n  const newB = Number(convertToDecimal(b))\r\n  const newC = Number(convertToDecimal(c))\r\n  const expression = `${newA === 0 ? `` : `${a}x^2`} \r\n    ${newB === 0 ? ``: `${newB < 0 ? `${b}` : `+${b}`}x`} \r\n    ${newC === 0 ? `` : `${newC < 0 ? `${c}` : `+${c}`}`}`\r\n\r\n  return math.parse(expression)\r\n}\r\n\r\n/**\r\n * @param {Array} functions: array of variables with their corresponding values to be used in term\r\n * @param {Array} operators: possible operators, such as '+', '-', etc.\r\n * @param {Number} depth of equation, i.e. how many levels of nesting in terms\r\n * @returns random term that uses functions variables and operators\r\n */\r\nfunction generateLimitPropertyTerm(functions, operators, depth = 2) {\r\n  if (depth === 0) {\r\n    // base case\r\n    const coefficient = getRandomNumber(2, 3); // coefficient of variable\r\n    const f = functions[getRandomNumber(0, functions.length - 1)].f // variable\r\n    return `(${coefficient}${f})`;\r\n  } else {\r\n    // recursive case\r\n    const operator = operators[getRandomNumber(0, operators.length - 1)]; // random operator\r\n    let leftOperand = generateLimitPropertyTerm(functions, operators, depth - 1);\r\n    let rightOperand = generateLimitPropertyTerm(functions, operators, depth - 1);\r\n\r\n    if (operator === \"^\") {\r\n      // exponent operator\r\n      const numerator = getRandomNumber(0, 1); // whether this will be a fractional exponent\r\n      if (numerator) {\r\n        // fractional exponent\r\n        // make sure result is whole number\r\n        const val = math.evaluate(leftOperand, convertArrayToObject(functions)); // evaluate\r\n        const root = val < 0 ? 3 : getRandomNumber(2, 3); // odd root if val < 0\r\n        const int = Math.round(math.evaluate(`nthRoot(${val}, ${root})`)); // evaluate what root should be\r\n\r\n        // constant to add to make whole number result\r\n        let add = math.evaluate(`${val} - ${int}^${root}`);\r\n        add = add > 0 ? ` - ${add}` : `+ ${Math.abs(add)}`;\r\n        return `nthRoot(${leftOperand}${add}, ${root})`\r\n      }\r\n\r\n      // normal power case\r\n      let rightOperand = `${getRandomNumber(2, 3)}`;\r\n      return `(${leftOperand}${operator}${rightOperand})`\r\n\r\n    } else if (operator === \"/\") {\r\n      // ensure whole number result \r\n      // evaluate operands\r\n      let left = math.evaluate(leftOperand, convertArrayToObject(functions))\r\n      let right = math.evaluate(rightOperand, convertArrayToObject(functions))\r\n\r\n      // ensure operands aren't 0. this is to make sure no issues with finding lcm\r\n      if (right === 0) {\r\n        rightOperand = `(${rightOperand} + 1)`; // add 1 if 0\r\n        right = math.evaluate(rightOperand, convertArrayToObject(functions));\r\n      }\r\n      if (left === 0) {\r\n        leftOperand = `(${leftOperand} + 1)`; // add 1 if 0\r\n        left = math.evaluate(leftOperand, convertArrayToObject(functions));\r\n      }\r\n\r\n      // find lcm and simplify node\r\n      const lcm = findLCM(left, right);\r\n      const l = math.simplify(`${Math.round(lcm / left)}*${leftOperand}`).toString().replaceAll(\" * \", \"\")\r\n\r\n      return `((${l})${operator}${rightOperand})`\r\n    } else {\r\n      // normal operand\r\n      return `(${leftOperand}${operator}${rightOperand})`\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generates one side of the fraction in trig limit problem involving sinx/x, x/sinx, (1 - cos x)/x\r\n * @param {number} degree of side (ex. 3 could mean x^2 sin x)\r\n * @param {string} multipliedAns used to keep trace of the current answer in generation process\r\n * @param {boolean} denominator whether we are generating a denminator (important since we can't have (1 - cos x) in the denominator and denominator will have 1 trig term or 1 poly term and at least another trig term)\r\n * @returns generated term and updated multipliedAns\r\n */\r\nconst generateSpecialTrig = \r\n  (degree, multipliedAns, denominator) => {\r\n  let term = \"1\"; // initialize term\r\n  let exclusions = []; // coeffs that have already been used\r\n\r\n  // iterate over degree\r\n  for (let i = 0; i < degree;) {\r\n    // while we are less than degree, generate random term\r\n    const trig = getRandomNumber(0, 9) > 7 || i > 0; // whether term is poly or trig\r\n    const exp = getRandomNumber(1, denominator ? degree - i - 1 : degree - i) // exp of term\r\n    const expText = exp > 1 ? `^${exp}` : \"\";\r\n\r\n    // coeff of x in term, ex. 3 in sin(3x)\r\n    const coeff = getRandomWithExclusions(1, 4, exclusions); \r\n    const coeffText = coeff !== 1 ? coeff : \"\";\r\n\r\n    exclusions.push(coeff); // update coeff exclusions\r\n\r\n    if (trig === true) {\r\n      // update ans\r\n      const add = `(${Math.pow(coeff, exp)})`\r\n      multipliedAns = (denominator ? multipliedAns + add : add + multipliedAns)\r\n\r\n      // term to generate\r\n      if (getRandomNumber(0, 1) === 0 || denominator) {\r\n        term += `\\\\sin${expText}(${coeffText}x)`\r\n      } else {\r\n        term += `(1 - \\\\cos(${coeffText}x))${expText}`\r\n      }\r\n    } else {\r\n      // poly term\r\n      multipliedAns = denominator ? multipliedAns + `(${coeff})` : `(${coeff})` + multipliedAns \r\n      term += `${coeffText}x${expText}`\r\n    }\r\n    // increment i by degree that we added\r\n    i += exp;\r\n  }\r\n\r\n  // remove beginning 1 from term\r\n  if (term.length > 1) {\r\n    term = term.substring(1)\r\n  }\r\n  return { term, multipliedAns }\r\n}\r\n\r\nexport { generateRandomPolynomial, generateRandomPolynomialWithPoint, fitPointsToQuadratic, generateLimitPropertyTerm, getPolynomialFunctionWithPoint, getPolynomialFunction, fitPointsToQuadraticFractions, generateSpecialTrig }","import * as math from \"mathjs\"\r\nconst nerdamer = require(\"nerdamer/all.min\")\r\n\r\n/**\r\n * Shuffles an array\r\n * @param {array} array array to be shuffled\r\n * @returns shuffled array\r\n */\r\nconst shuffleArray =  (array: Array<any>): Array<any> => {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1)); // Generate a random index from 0 to i\r\n\r\n    // Swap elements at i and j\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * generates a random number\r\n * @param {number} min minimum value of random number\r\n * @param {number} max maximum value of random number\r\n * @returns random number in the range [min, max]\r\n */\r\nconst getRandomNumber = (min: number, max: number): number => {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\n/**\r\n * generates a random number with exclusions\r\n * @param {number} min minimum value of random number\r\n * @param {number} max maximum value of random number\r\n * @param {array} exclusions numbers to be excluded from generation\r\n * @returns random number in the range [min, max] excluding exclusions\r\n */\r\nconst getRandomWithExclusions = \r\n  (min: number, max: number, exclusions: Array<number>): number => {\r\n  const validValues = [];\r\n  for (let i = min; i <= max; i++) {\r\n    if (!exclusions.includes(i)) {\r\n      validValues.push(i);\r\n    }\r\n  }\r\n\r\n  if (validValues.length === 0) {\r\n    return max;\r\n  }\r\n\r\n  const randomIndex = getRandomNumber(0, validValues.length - 1);\r\n  return validValues[randomIndex];\r\n}\r\n\r\n/**\r\n * @param {Number} n number of values to generate\r\n * @param {boolean} increasing true if values should be increasing, false if decreasing\r\n * @returns array of n ordered numbers \r\n */\r\nconst generateOrderedValues = \r\n  (n: number, increasing: boolean, extreme: number = 10, \r\n    increment: number = 4): Array<number> => {\r\n  if (n <= 0) {\r\n    return [];\r\n  }\r\n\r\n  const values = [Math.floor(Math.random() * extreme) + 1]; // Initialize with a random value\r\n\r\n  while (values.length < n) {\r\n    // generate a value greater than the last one\r\n    const nextDiff = getRandomNumber(1, increment) * (increasing ? 1 : -1);\r\n    const nextValue = values[values.length - 1] + nextDiff;\r\n    values.push(nextValue);\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\n/**\r\n * \r\n * @param {String} polynomial string with a polynomial\r\n * @returns polynomial sorted in order of degree\r\n */\r\nconst sortPolynomialByDegree = (polynomial: string): string => {\r\n  // get coefficients with nerdamer\r\n  const coefficients = nerdamer.coeffs(polynomial, 'x');\r\n  let ans = \"\";\r\n  const coeffs = [];\r\n  coefficients.each(function (e) {\r\n    coeffs.push(nerdamer(e).toString());\r\n  })\r\n\r\n  // build expression\r\n  for (let i = coeffs.length - 1; i >= 0; i--) {\r\n    if (coeffs[i] === \"0\") continue; // skip 0 terms\r\n\r\n    // add \"+\" before positive coefficient terms\r\n    if (i !== coeffs.length - 1) {\r\n      if (Number(coeffs[i]) > 0) {\r\n        ans += \"+\"\r\n      }\r\n    }\r\n\r\n    if (coeffs[i] !== \"1\" || (coeffs[i] === \"1\" && i === 0)) {\r\n      ans += coeffs[i] === \"-1\" ? i === 0 ? \"-1\" : \"-\" : coeffs[i];\r\n    }\r\n\r\n    if (i > 1) {\r\n      ans += `x^${i}`;\r\n    } else if (i === 1) {\r\n      ans += 'x';\r\n    }\r\n  }\r\n  return ans;\r\n}\r\n\r\n/**\r\n * Returns polynomial expression given coefficients of polynomial\r\n * @param coeffs to use in building polynomial\r\n * @returns expression\r\n */\r\nconst buildPolynomialFromCoeffs = (coeffs: any[]): string => {\r\n  for (let i = 0; i < coeffs.length; i++) {\r\n    coeffs[i] = String(coeffs[i])\r\n  }\r\n  \r\n  let ans = ''\r\n  for (let i = coeffs.length - 1; i >= 0; i--) {\r\n    if (coeffs[i] === \"0\") continue; // skip 0 terms\r\n\r\n    // add \"+\" before positive coefficient terms\r\n    if (i !== coeffs.length - 1) {\r\n      if (Number.isNaN(Number(coeffs[i])) || Number(coeffs[i]) > 0) {\r\n        ans += \"+\"\r\n      }\r\n    }\r\n\r\n    if (coeffs[i] !== \"1\" || (coeffs[i] === \"1\" && i === 0)) {\r\n      ans += coeffs[i] === \"-1\" ? i === 0 ? \"-1\" : \"-\" : coeffs[i];\r\n    }\r\n\r\n    if (i > 1) {\r\n      ans += `x^${i}`;\r\n    } else if (i === 1) {\r\n      ans += 'x';\r\n    }\r\n  }\r\n  return ans;\r\n}\r\n\r\n/**\r\n * Extracts coefficients of polynomial in increasing order of degree\r\n * @param polynomial string with polynomial expression\r\n * @returns Coefficients of polynomial in increasing order of degree\r\n */\r\nconst getCoeffsOfPolynomial = (polynomial: string): number[] => {\r\n  const coefficients = nerdamer.coeffs(polynomial, 'x');\r\n  const coeffs = [];\r\n  coefficients.each(function (e) {\r\n    coeffs.push(Number(nerdamer(e).toString()));\r\n  })\r\n\r\n  return coeffs\r\n}\r\n\r\n/**\r\n * Finds roots of given polynomial expression (works only with polynomials of degree 2)\r\n * @param polynomial string wth polynomial expression to find roots\r\n * @returns vector of roots of polynomial as decimals\r\n * if there is only 1 root, it will return a vector of length 2 with both values the same root\r\n */\r\nconst getRootsOfPolynomial = (polynomial: string): string[] => {\r\n  const roots = nerdamer(`roots(${polynomial})`)\r\n  const elements = roots.symbol.elements\r\n  const r1 = convertToDecimal(elements[0].toString())\r\n  const r2 = elements[1] === undefined ? r1 : convertToDecimal(elements[1].toString())\r\n  return [r1, r2]\r\n}\r\n\r\n/**\r\n * converts provided number (potentially a fraction) to a decimal\r\n * @param number string of number to convert to decimal\r\n * @returns decimal equivalent of number\r\n */\r\nconst convertToDecimal = (number: string): string => {\r\n  return nerdamer(number).text(`decimals`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {String} xval xvalue from which to create factor\r\n * @returns String in form (x - p), where p is the xval\r\n */\r\nconst getStringFactorFromXval = (xval: number): string => {\r\n  if (xval < 0) {\r\n    return `(x + ${Math.abs(xval)})`\r\n  } else if (xval > 0) {\r\n    return `(x - ${xval})`\r\n  } else {\r\n    return `(x)`\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Array} array where each element is in the form {f: String, value: Number}\r\n * @returns object with keys as all the f Strings, values as the value of that String\r\n */\r\nconst convertArrayToObject = (array: Array<any>): any => {\r\n  const obj = {};\r\n  for (let i = 0; i < array.length; i++) {\r\n    const currentObj = array[i];\r\n    if (currentObj.hasOwnProperty('f')) {\r\n      const key = currentObj['f'];\r\n      obj[key] = currentObj['value'];\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * @param {Number} a \r\n * @param {Number} b \r\n * @returns least common multiple of a and b\r\n */\r\nconst findLCM = (a: number, b: number): number => {\r\n  // Calculate the greatest common divisor (GCD) using Euclidean algorithm\r\n  function findGCD(x, y) {\r\n    if (y === 0) {\r\n      return x;\r\n    }\r\n    return findGCD(y, x % y);\r\n  }\r\n\r\n  // LCM is the product of the two numbers divided by their GCD\r\n  return (a * b) / findGCD(a, b);\r\n}\r\n\r\n/**\r\n * @param {Number} xVal at which table will \"zoom in\"\r\n * @param {Array} values to use as yvalues in table\r\n * @param {Number} start of xs in table\r\n * @param {Number} end of xs in table\r\n * @returns data array containing x, y pairs for points that could be used in a limit table\r\n */\r\nconst generateLimitTableData = \r\n  (xVal: number, values: Array<number>, start: number, end: number): any => {\r\n  const increasing = values[1] - values[0] >= 0;\r\n  const data = [];\r\n  // build table data\r\n  for (let i = start; i <= end; i++) {\r\n    const val = values[i - start];\r\n\r\n    // zooming in to the left of xVal\r\n    if (i === xVal && xVal !== start) {\r\n      data.push({ x: i - 0.1, y: val - (increasing ? 0.1 : -0.1) })\r\n      data.push({ x: i - 0.01, y: val - (increasing ? 0.01 : -0.01) })\r\n      data.push({ x: i - 0.001, y: val - (increasing ? 0.001 : -0.001) })\r\n    }\r\n\r\n    data.push({ x: i, y: val });  // other xvalues\r\n\r\n    // zooming in to the right of xval\r\n    if (i === xVal && xVal !== end) {\r\n      data.push({ x: i + 0.001, y: val + (increasing ? 0.001 : -0.001) })\r\n      data.push({ x: i + 0.01, y: val + (increasing ? 0.01 : -0.01) })\r\n      data.push({ x: i + 0.1, y: val + (increasing ? 0.1 : -0.1) })\r\n    }\r\n  }\r\n\r\n  return {data}\r\n}\r\n\r\n/**\r\n * @param {String} polynomial to format\r\n * @returns formatted latex polynomial formatted with mathjs\r\n */\r\nconst formatPolynomialToLatex = (polynomial: string): any => {\r\n  const str: String = math.simplifyCore(polynomial).toTex()\r\n  return str.replaceAll('\\\\cdot', '').replaceAll('~', '');\r\n}\r\n\r\n/**\r\n * @param {String} expression to format\r\n * @returns formatted latex polynomial formatted with nerdamer\r\n */\r\nconst nerdamerFormatToLatex = (expression: string): string => {\r\n  return nerdamer(expression).toTeX().replaceAll('\\\\cdot', '').replaceAll('~', '')\r\n}\r\n\r\nexport { getRandomNumber, getRandomWithExclusions, generateOrderedValues, shuffleArray, sortPolynomialByDegree, getStringFactorFromXval, convertArrayToObject, findLCM, generateLimitTableData, formatPolynomialToLatex, nerdamerFormatToLatex, getCoeffsOfPolynomial, getRootsOfPolynomial, convertToDecimal, buildPolynomialFromCoeffs }","import * as d3 from 'd3';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET } from \"./constants\";\r\n\r\n/**\r\n * generates graphing data for mathematical function\r\n * @param {function} f function for which to generate data\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @param {number} dataGap how close to generate function data\r\n * @returns array of data with generated values\r\n */\r\nconst generateFunctionData = (f, min, max, dataGap = 0.01) => {\r\n  let data = [];\r\n\r\n  for (let i = min; i <= max; i += dataGap) {\r\n    const x = i;\r\n    const y = f(i)\r\n    data.push({ x, y });\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * appends graph of a mathematical function on an svg\r\n * @param {svg} svg element on which to draw function graph\r\n * @param {function} f function to graph \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {color} color color of graph\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @param {string} classes custom string of classes to include in function path/arrows\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @param {boolean} leftArrow whether there should be an arrow on the left of the graph\r\n * @param {boolean} rightArrow whether there should be an arrow on the right of the graph\r\n * @param {String} type can be \"asymptotic\"\r\n * @param {number} dataGap how close to generate function data\r\n * @returns data that was used to graph function, id of svg path of function\r\n */\r\nconst createFunctionGraph = (svg, f, width, height, color, xScale, yScale, classes, min, max, leftArrow, rightArrow, type, dataGap) => {\r\n  let data = generateFunctionData(f, min, max, dataGap); // generate data\r\n\r\n  // filter data\r\n  data = data.filter((d) => d.x > Math.min(xScale.invert(0), max) &&\r\n    d.x < Math.max(xScale.invert(width), min) &&\r\n    d.y > yScale.invert(height) &&\r\n    d.y < yScale.invert(0))\r\n\r\n  if (type === \"asymptotic\") {\r\n    // make left part of graph go to edge\r\n    if (min > xScale.invert(0)) {\r\n      // get data point of intersection with top/bottom of graph\r\n      const y = data[0].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, min + 0.00001, data[0].x, 0.01);\r\n      if (d) data.unshift({ x: d, y: f(d) }); // add point to beginning of data\r\n    }\r\n\r\n    // make right part of graph go to edge\r\n    if (max < xScale.invert(width)) {\r\n      // data point of intersection with top/bottom\r\n      const y = data[data.length - 1].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, data[data.length - 1].x, max - 0.00001, 0.01);\r\n      if (d) data.push({ x: d, y: f(d) }); // add point to end of data\r\n    }\r\n  }\r\n\r\n  const line = d3.line()\r\n    .x(d => xScale(d.x))\r\n    .y(d => yScale(d.y))\r\n\r\n  // arrow markers for graph\r\n  const markerSize = 5;\r\n  const name = `${uuidv4()}function-arrow`\r\n  createArrowMarker(name, svg, markerSize, color, classes)\r\n\r\n  // create graph\r\n  const id = uuidv4();\r\n  svg.append('path')\r\n    .datum(data)\r\n    .attr('data-uuid', id)\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('fill', 'none')\r\n    .attr('stroke', color)\r\n    .attr('stroke-width', 2)\r\n    .attr('marker-end', rightArrow ? `url(#${name})` : null)\r\n    .attr('marker-start', leftArrow ? `url(#${name})` : null)\r\n    .attr('d', line);\r\n\r\n  svg.select(\".tick-text\").raise(); // raise tickmarks on top\r\n  svg.select(\".tick-marks\").raise(); // raise tickmarks on top\r\n\r\n  return { data, id };\r\n}\r\n\r\n/**\r\n * \r\n * @param {function} func for which to find intersections\r\n * @param {number} y of intersection point\r\n * @param {number} xMin of domain\r\n * @param {number} xMax of domain\r\n * @param {number} tolerance for how far away ans can be from y\r\n * @returns \r\n */\r\nfunction findIntersections(func, y, xMin, xMax, tolerance) {\r\n  var a = xMin;\r\n  var b = xMax;\r\n\r\n  // binary search\r\n  while (b - a > 0.00001) {\r\n    var xMid = (a + b) / 2;\r\n    var yMid = func(xMid);\r\n\r\n    if (y > 0 && yMid <= y && y - yMid < tolerance) {\r\n      return xMid;\r\n    }\r\n    if (y < 0 && yMid >= y && yMid - y < tolerance) {\r\n      return xMid;\r\n    }\r\n\r\n    // update based on graph behavior\r\n    if (func(xMin) < func(xMax) && yMid < y) {\r\n      // increasing graph, y too low\r\n      a = xMid;\r\n    } else if (func(xMin) < func(xMax)) {\r\n      // increasing graph, y too high\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax) && yMid < y) {\r\n      // decreasing graph, y too low\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax)) {\r\n      // decreasing graph, y too high\r\n      a = xMid;\r\n    }\r\n  }\r\n\r\n  return (a + b) / 2; // nothing found so get midpoint\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg on which to draw function graph\r\n * @param {Array} functions to graph, each has the f, min/max domain, and includesLeft/includesRight, which indicates whether min/max are included or not\r\n * @param {int} width of svg\r\n * @param {int} height of svg\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @returns {Array} array of all data and ids of function graphs\r\n */\r\nconst createMultipleFunctionsGraph = (svg, functions, width, height, xScale, yScale) => {\r\n  const dataArray = [];\r\n\r\n  for (let i = 0; i < functions.length; i++) {\r\n    // add graph for each function\r\n    const func = functions[i];\r\n    const { data, id } = createFunctionGraph(svg, func.f, width, height, null, xScale, yScale, func.classes, func.min, func.max, func.leftArrow, func.rightArrow, func.type, func.dataGap);\r\n\r\n    dataArray[dataArray.length] = { data, id }; // save return values\r\n\r\n    // append circles as holes/points if needed\r\n    if (func.leftCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeLeft ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.min))\r\n        .attr('cy', yScale(func.f(func.min)))\r\n        .attr('r', 3)\r\n    }\r\n\r\n    if (func.rightCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeRight ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.max))\r\n        .attr('cy', yScale(func.f(func.max)))\r\n        .attr('r', 3)\r\n    }\r\n  }\r\n\r\n  return { dataArray }\r\n}\r\n\r\n/**\r\n * Adds points to svg \r\n * @param {svg} svg svg on which to add points\r\n * @param {Array} points to add\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n */\r\nconst addPointsToGraph = (svg, points, xScale, yScale) => {\r\n  for (let i = 0; i < points.length; i++) {\r\n    svg\r\n    .append('circle')\r\n    .attr('class', 'fill stroke ' + points[i].classes)\r\n    .attr('cx', xScale(points[i].x))\r\n    .attr('cy', yScale(points[i].y))\r\n    .attr('r', 3)\r\n  } \r\n\r\n}\r\n\r\n/**\r\n * creates -10 by 10 (default, diff dimensions can be specified) blank canvas on top of which graphs can be drawn \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {Ref} svgRef reference to svg where graph should be drawn\r\n * @param {number} textSize size of text of graph labels\r\n * @param {number} minx minimum domain value\r\n * @param {number} maxx maximum domain value\r\n * @param {number} miny minimum range value\r\n * @param {number} maxy maximum range value\r\n * @returns width, height, xscale, and yscale of graph\r\n */\r\nconst createBlankCanvas = (width, height, svgRef, textSize, minx = -10, maxx = 10, miny = -10, maxy = 10) => {\r\n  const numCells = 20;\r\n  const half = (width / 2) / numCells;\r\n  const color = \"#707070\"\r\n  const size = 5;\r\n\r\n  const svg = d3.select(svgRef.current);\r\n  svg.selectAll(\"*\").remove();\r\n\r\n  svg\r\n    .attr('width', width)\r\n    .attr('height', height)\r\n\r\n  // scales\r\n  const xScale = d3.scaleLinear()\r\n    .domain([minx, maxx])\r\n    .range([half, width - half]);\r\n\r\n  const yScale = d3.scaleLinear()\r\n    .domain([miny, maxy])\r\n    .range([-1 * half + height, half]);\r\n\r\n  // build tick marks on axes\r\n  const tickMarks = svg.append('g')\r\n    .attr('class', 'tick-marks');\r\n\r\n  const tickText = svg.append('g')\r\n    .attr('class', 'tick-text')\r\n\r\n  const xGrid = svg.append('g')\r\n    .attr('class', 'x-grid-line')\r\n\r\n  const yGrid = svg.append('g')\r\n    .attr('class', 'y-grid-line')\r\n\r\n\r\n  const tickCount = 20;\r\n  const tickCount2 = tickCount / 2;\r\n\r\n  const ticks = d3.range(tickCount + 1).map((d, i) => minx + (i * ((maxx - minx) / tickCount)));\r\n  const ticks2 = d3.range(tickCount2 + 1).map((d, i) => minx + (i * ((maxx - minx) / tickCount2)));\r\n\r\n  ticks.forEach(tick => {\r\n    xGrid.append(\"line\")\r\n      .attr(\"x1\", xScale(tick))\r\n      .attr(\"x2\", xScale(tick))\r\n      .attr(\"y1\", 0)\r\n      .attr(\"y2\", height)\r\n      .attr(\"stroke\", \"lightgray\");\r\n  })\r\n  \r\n  // add marks and text to xaxis\r\n  ticks2.forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(tick))\r\n      .attr(\"x2\", xScale(tick))\r\n      .attr(\"y1\", yScale(0) - 4)\r\n      .attr(\"y2\", yScale(0) + 4)\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(tick) + (tick < 0 ? 1.5 : -1.5))\r\n      .attr(\"y\", yScale(0) + 3)\r\n      .attr('alignment-baseline', 'hanging')\r\n      .attr('text-anchor', tick < 0 ? 'start' : 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(Math.round(tick * 100) / 100)\r\n  })\r\n\r\n  ticks.forEach(tick => {\r\n    yGrid.append(\"line\")\r\n      .attr(\"class\", \"y-grid-line\")\r\n      .attr(\"x1\", 0)\r\n      .attr(\"x2\", width)\r\n      .attr(\"y1\", yScale(tick))\r\n      .attr(\"y2\", yScale(tick))\r\n      .attr(\"stroke\", \"lightgray\");\r\n  })\r\n\r\n  // add marks and text to y axis\r\n  ticks2.forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(0) - 4)\r\n      .attr(\"x2\", xScale(0) + 4)\r\n      .attr(\"y1\", yScale(tick))\r\n      .attr(\"y2\", yScale(tick))\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(0) - 3)\r\n      .attr(\"y\", yScale(tick) + (tick < 0 ? -1.5 : 1.5))\r\n      .attr('alignment-baseline', tick < 0 ? 'baseline' : 'hanging')\r\n      .attr('text-anchor', 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(Math.round(tick * 100) / 100)\r\n  })\r\n\r\n  // draw actual x and y axes\r\n  const name = \"axes-arrow\"\r\n  createArrowMarker(name, svg, size, color);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", 0)\r\n    .attr(\"x2\", width)\r\n    .attr(\"y1\", yScale(0))\r\n    .attr(\"y2\", yScale(0))\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", xScale(0))\r\n    .attr(\"x2\", xScale(0))\r\n    .attr(\"y1\", height)\r\n    .attr(\"y2\", 0)\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  return { width, height, xScale, yScale }\r\n};\r\n\r\n/**\r\n * generates custom arrow marker to be used in graphs of functions\r\n * @param {string} name identifier name of arrow marker being generated\r\n * @param {svg} svg svg where marker should be appended\r\n * @param {number} size size of marker\r\n * @param {string} color color of marker\r\n * @param {string} classes custom classes to be added to marker\r\n */\r\nfunction createArrowMarker(name, svg, size, color, classes) {\r\n  svg.append(\"defs\").append(\"marker\")\r\n    .attr(\"id\", name)\r\n    .attr('class', 'fill ' + classes)\r\n    .attr(\"refX\", size)\r\n    .attr(\"refY\", size / 2)\r\n    .attr(\"markerWidth\", size)\r\n    .attr(\"markerHeight\", size)\r\n    .attr(\"orient\", \"auto-start-reverse\")\r\n    .attr('fill', color)\r\n    .append(\"path\")\r\n    .attr(\"d\", `M0,0 V${size} Q${size * 2},${size / 2} 0,0`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg in which to append limit line\r\n * @param {function} line function for 'd' attribute of path\r\n * @param {number} x1 x1 of line\r\n * @param {number} x2 x2 of line\r\n * @param {number} y1 y1 of line\r\n * @param {number} y2 y2 of line\r\n * @param {string} name of arrow markers on line\r\n * @param {string} classes custom classes o add to generated arrow\r\n */\r\nfunction createLimitLine(svg, line, x1, x2, y1, y2, name, classes) {\r\n  // check if arrow marker exists\r\n  if (d3.select(`#${name}`).empty()) {\r\n    createArrowMarker(name, svg, 4, null, classes)\r\n  }\r\n\r\n  // add limit line\r\n  svg.append('path')\r\n    .datum([{ x: x1, y: y1 }, { x: x2, y: y2 }])\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('stroke-width', 1)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('d', line)\r\n}\r\n\r\n/**\r\n * finds hypotenuse frm width/height of triangle\r\n * @param {number} x width\r\n * @param {number} y height\r\n * @returns hypotenuse of triangle formed with width/height\r\n */\r\nfunction findHypotenusefromSlope(x, y) {\r\n  return Math.sqrt(((x) ** 2) + ((y) ** 2))\r\n}\r\n\r\n/**\r\n * converts points from svg scale to normal -10 to 10 x/y\r\n * @param {object} far far point\r\n * @param {object} close close point\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @returns points object with converted x/y values\r\n */\r\nfunction convertScale(far, close, xScale, yScale) {\r\n  const farx = xScale.invert(far.x)\r\n  const closex = xScale.invert(close.x)\r\n  const fary = yScale.invert(far.y)\r\n  const closey = yScale.invert(close.y)\r\n  return { farx, closex, fary, closey }\r\n}\r\n\r\n/**\r\n * perpendicular slope from points\r\n * @param {object} points object representing points from which to compute slope\r\n * @returns perpendicular slope from points\r\n */\r\nfunction findSlope(points) {\r\n  let ans = (-1 * (points.farx - points.closex)) / (points.fary - points.closey)\r\n  return ans;\r\n}\r\n\r\n/**\r\n * Finds offsets of lines/text from function line\r\n * @param {object} points object representing points from which line needs to be offset\r\n * @param {number} axisOffset how much line should be offset\r\n * @returns x, y representing by how much lines need to move in each direction\r\n */\r\nfunction findOffsets(points, axisOffset) {\r\n  let slope = findSlope(points)\r\n  const hyp = findHypotenusefromSlope(1, slope);\r\n  let scale = -1 * axisOffset / hyp;\r\n  if (slope > 0) scale *= -1\r\n  const x = scale;\r\n  const y = (scale) * slope;\r\n\r\n  return { x, y }\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {svg} svg on which to append lines\r\n * @param {Element} functionLine line for function\r\n * @param {int} pathLength length of path up till point\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @param {function} line function that creates 'd' attribute in svg path\r\n * @param {String} fColor color of function\r\n * @param {boolean} right true if the limit line to be drawn should be from the right, false if left\r\n * @param {String} markerName custom name of arrow marker\r\n * @returns points of the line in svg scale\r\n */\r\n\r\nfunction createFunctionLimitLine(svg, functionLine, pathLength, xScale, yScale, line, fColor, right, markerName) {\r\n\r\n  // modify lengths based on if the arrow is from the left or the right\r\n  let farDistLength = xScale(FAR_DIST) - xScale(0);\r\n  farDistLength = right ? farDistLength : (-1 * farDistLength);\r\n  let closeDistLength = xScale(CLOSE_DIST) - xScale(0);\r\n  closeDistLength = right ? closeDistLength : (-1 * closeDistLength)\r\n\r\n  // arrow from the left\r\n  const farPoint = functionLine.getPointAtLength(pathLength + farDistLength)\r\n  const closePoint = functionLine.getPointAtLength(pathLength + closeDistLength)\r\n  const pointsOne = convertScale(farPoint, closePoint, xScale, yScale)\r\n  const offsetsOne = findOffsets(pointsOne, AXIS_OFFSET);\r\n\r\n  if (isNaN(offsetsOne.y)) offsetsOne.y = AXIS_OFFSET;\r\n\r\n  createLimitLine(svg, line,\r\n    pointsOne.farx + offsetsOne.x,\r\n    pointsOne.closex + offsetsOne.x,\r\n    pointsOne.fary + offsetsOne.y,\r\n    pointsOne.closey + offsetsOne.y,\r\n    markerName ? markerName : 'f-limits', fColor)\r\n\r\n  return { closePoint, farPoint }\r\n}\r\n\r\nexport { createFunctionGraph, createBlankCanvas, createArrowMarker, generateFunctionData, createLimitLine, findHypotenusefromSlope, convertScale, findSlope, findOffsets, createMultipleFunctionsGraph, createFunctionLimitLine, addPointsToGraph }\r\n"],"names":["FAR_DIST","window","outerWidth","CLOSE_DIST","AXIS_OFFSET","GRAPH_SIZE","COLORS","compressPolynomial","expression","max","values","node","math","maxabs","Math","apply","concat","_toConsumableArray","i","abs","evaluate","x","scale","ceil","generateRandomPolynomial","degree","f","data","generateFunctionData","filter","d","y","move","minx","maxx","floor","length","getRandomWithExclusions","round","min","toString","modifyForWholeNumber","getPolynomialFunction","skipConstant","arguments","undefined","guaranteedTermAtDegree","coefficients","push","getRandomNumber","terms","map","coef","exp","t","reverse","join","replace","getPolynomialFunctionWithPoint","currVal","diff","generateRandomPolynomialWithPoint","yval","fitPointsToQuadratic","points","console","error","x1","y1","x2","y2","x3","y3","det","a","b","c","generateLimitPropertyTerm","functions","operators","depth","coefficient","operator","leftOperand","rightOperand","val","convertArrayToObject","root","int","add","left","right","lcm","findLCM","l","replaceAll","generateSpecialTrig","multipliedAns","denominator","term","exclusions","trig","expText","coeff","coeffText","pow","substring","nerdamer","require","shuffleArray","array","j","random","_ref","validValues","includes","generateOrderedValues","n","increasing","extreme","increment","nextDiff","nextValue","sortPolynomialByDegree","polynomial","coeffs","ans","each","e","Number","buildPolynomialFromCoeffs","String","isNaN","getCoeffsOfPolynomial","getRootsOfPolynomial","elements","symbol","r1","convertToDecimal","number","text","getStringFactorFromXval","xval","obj","currentObj","hasOwnProperty","findGCD","generateLimitTableData","xVal","start","end","formatPolynomialToLatex","toTex","nerdamerFormatToLatex","toTeX","dataGap","createFunctionGraph","svg","width","height","color","xScale","yScale","classes","leftArrow","rightArrow","type","invert","findIntersections","unshift","line","d3","name","uuidv4","createArrowMarker","id","append","datum","attr","select","raise","func","xMin","xMax","tolerance","xMid","yMid","createMultipleFunctionsGraph","dataArray","_createFunctionGraph","leftCircle","includeLeft","rightCircle","includeRight","addPointsToGraph","createBlankCanvas","svgRef","textSize","miny","maxy","half","current","selectAll","remove","domain","range","tickMarks","tickText","xGrid","yGrid","ticks","tickCount","ticks2","tickCount2","forEach","tick","style","size","createLimitLine","empty","convertScale","far","close","farx","closex","fary","closey","findOffsets","axisOffset","slope","findSlope","hyp","sqrt","findHypotenusefromSlope","createFunctionLimitLine","functionLine","pathLength","fColor","markerName","farDistLength","closeDistLength","farPoint","getPointAtLength","closePoint","pointsOne","offsetsOne"],"sourceRoot":""}