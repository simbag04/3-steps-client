{"version":3,"file":"static/js/635.b4df7332.chunk.js","mappings":"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","sources":["components/content-components/graphs/LimitExampleGraph.tsx","components/latex/Piecewise.tsx","helpers/constants.ts","helpers/graph-helpers.ts","topics/01-limits/01-understanding-limits/Sections.tsx","topics/01-limits/01-understanding-limits/learn-content.tsx"],"sourcesContent":["/**\r\n * Creates graph of function f showing limit at xval\r\n */\r\n\r\nimport { useEffect, useRef } from \"react\"\r\nimport { createFunctionGraph, createBlankCanvas, createFunctionLimitLine, createLimitLine, convertScale, findOffsets } from \"../../../helpers/graph-helpers\";\r\nimport { AXIS_OFFSET, CLOSE_DIST, FAR_DIST } from \"../../../helpers/constants\";\r\nimport * as d3 from 'd3';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport '../../../styles/graph.css'\r\nimport React from \"react\";\r\n\r\ninterface LimitExampleGraphProps {\r\n  f: Function, // function to generate graph of\r\n  xval: number, // xvalue at which to show limit\r\n  y: number, // y of function - could be different from f(xval) if there's a hole, or null if f is undefined at xval\r\n  fColor: string, //classes to add to function graph\r\n  xColor: string, // classes to add to x limit arrows\r\n  yColor: string, // classes to add to y limit arrows\r\n  size: number // size of graph\r\n}\r\n\r\nconst LimitExampleGraph: React.FC<LimitExampleGraphProps> = ({ f, xval, y, fColor, xColor, yColor, size }) => {\r\n  const svgRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (svgRef.current) {\r\n      const textSize = 11;\r\n      const graphSize = size;\r\n      const { height, width, xScale, yScale } =\r\n        createBlankCanvas(graphSize, graphSize, svgRef, textSize);\r\n\r\n      const svg = d3.select(svgRef.current)\r\n      const yval = f(xval);\r\n\r\n      const line = d3.line()\r\n        .x(d => xScale(d.x))\r\n        .y(d => yScale(d.y))\r\n\r\n      // dashed lines going to x and y axes\r\n      svg.append('path')\r\n        .datum([{ x: 0, y: yval }, { x: xval, y: yval }])\r\n        .attr('class', 'stroke ' + yColor)\r\n        .attr('stroke-width', 2)\r\n        .style('stroke-dasharray', 2)\r\n        .attr('d', line)\r\n\r\n      svg.append('path')\r\n        .datum([{ x: xval, y: yval }, { x: xval, y: 0 }])\r\n        .attr('class', 'stroke ' + xColor)\r\n        .attr('stroke-width', 2)\r\n        .style('stroke-dasharray', 2)\r\n        .attr('d', line)\r\n\r\n      const { data, id } = createFunctionGraph(svg, f, width, height, null, xScale, yScale, fColor, -11, 11, true, true);\r\n      createAllLimitLines(svg, line, xval, yval,\r\n        xColor, yColor, fColor,\r\n        xScale, yScale, data, id, textSize);\r\n\r\n      // hole at xval, yval\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'hole fill stroke ' + fColor)\r\n        .attr('cx', xScale(xval))\r\n        .attr('cy', yScale(yval))\r\n        .attr('r', 3)\r\n\r\n      // point at xval, y\r\n      if (y !== null) {\r\n        svg\r\n          .append('circle')\r\n          .attr('class', 'fill stroke ' + fColor)\r\n          .attr('cx', xScale(xval))\r\n          .attr('cy', yScale(y))\r\n          .attr('r', 3)\r\n      }\r\n    }\r\n\r\n  }, [svgRef, f, fColor, xColor, xval, y, yColor, size])\r\n\r\n  return (\r\n    <svg ref={svgRef} />\r\n  )\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg to append lmit lines to\r\n * @param {function} line functionthat creates 'd' attribute in svg path\r\n * @param {number} xval xvalue of point where limit is being generated\r\n * @param {number} yval yvalue of point\r\n * @param {string} xColor classes to be added to x limit lines\r\n * @param {string} yColor classes to be added to y limit lines\r\n * @param {string} fColor classes to be added to f limit lines\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @param {Array} data array of data for original function\r\n * @param {id} id id of function path\r\n * @param {number} textSize text size of label\r\n */\r\nfunction createAllLimitLines(svg, line, xval, yval,\r\n  xColor, yColor, fColor,\r\n  xScale, yScale, data, id, textSize) {\r\n\r\n  // horizontal and vertical arrows\r\n  createLimitLine(svg, line, xval - FAR_DIST,\r\n    xval - CLOSE_DIST,\r\n    AXIS_OFFSET, AXIS_OFFSET, 'x-limits', xColor)\r\n  createLimitLine(svg, line, xval + FAR_DIST,\r\n    xval + CLOSE_DIST,\r\n    AXIS_OFFSET, AXIS_OFFSET, 'x-limits', xColor)\r\n\r\n  svg.append('circle')\r\n    .attr('class', 'fill stroke ' + xColor)\r\n    .attr('cx', xScale(xval))\r\n    .attr('cy', yScale(0))\r\n    .attr('r', 1)\r\n\r\n  createLimitLine(svg, line, AXIS_OFFSET,\r\n    AXIS_OFFSET,\r\n    yval - FAR_DIST, yval - CLOSE_DIST, 'y-limits', yColor)\r\n  createLimitLine(svg, line, AXIS_OFFSET,\r\n    AXIS_OFFSET,\r\n    yval + FAR_DIST, yval + CLOSE_DIST, 'y-limits', yColor)\r\n\r\n  svg.append('circle')\r\n    .attr('class', 'fill stroke ' + yColor)\r\n    .attr('cx', xScale(0))\r\n    .attr('cy', yScale(yval))\r\n    .attr('r', 1)\r\n\r\n  // function arrows\r\n  const dataUpToPoint = data.filter((d) => d.x < xval);\r\n\r\n  // create path up to point to get its length\r\n  const pointId = uuidv4();\r\n  svg.append('path')\r\n    .datum(dataUpToPoint)\r\n    .attr('data-uuid', pointId)\r\n    .attr('fill', 'none')\r\n    .attr('d', line);\r\n\r\n  // get path length and use that to find points at which to genrate limit arrows\r\n  const functionLine = d3.select(`[data-uuid=\"${id}\"]`).node();\r\n  const pathLength = d3.select(`[data-uuid=\"${pointId}\"]`).node().getTotalLength();\r\n\r\n  const leftLine = createFunctionLimitLine(\r\n    svg, functionLine, pathLength, xScale, yScale, line, fColor, false);\r\n  const rightLine = createFunctionLimitLine(\r\n    svg, functionLine, pathLength, xScale, yScale, line, fColor, true);\r\n\r\n  const farPointOne = leftLine.farPoint;\r\n  const farPointTwo = rightLine.farPoint;\r\n\r\n  // text at point\r\n\r\n  // get offset values\r\n  const pointsText = convertScale(farPointOne, farPointTwo, xScale, yScale);\r\n  const offsetsText = findOffsets(pointsText, 3 * AXIS_OFFSET);\r\n\r\n  // adjust offset values by ensuring they are a minimum distance away from line\r\n  offsetsText.y = isNaN(offsetsText.y) ? 0.7 : offsetsText.y;\r\n  if (offsetsText.y <= 0) {\r\n    offsetsText.y = Math.min(-0.5, offsetsText.y);\r\n  } else {\r\n    offsetsText.y = Math.max(0.5, offsetsText.y);\r\n  }\r\n\r\n  if (offsetsText.x <= 0) {\r\n    offsetsText.x = Math.min(-1.2, offsetsText.x);\r\n  } else {\r\n    offsetsText.x = Math.max(1.2, offsetsText.x);\r\n  }\r\n\r\n  // if text is too close to axes, move it on the other side of the line\r\n  if ((xval <= 3 && xval >= 0) && offsetsText.x < 0) {\r\n    offsetsText.x = (offsetsText.x * -1);\r\n    offsetsText.y = offsetsText.y * -1;\r\n  }\r\n\r\n  if (xval >= -3 && xval < 0 && offsetsText.x > 0) {\r\n    offsetsText.x = (offsetsText.x * -1);\r\n    offsetsText.y = offsetsText.y * -1;\r\n  }\r\n\r\n  // add text\r\n  svg.append('text')\r\n    .attr('x', xScale(xval + offsetsText.x))\r\n    .attr('y', yScale(yval + offsetsText.y))\r\n    .attr('text-anchor', 'middle')\r\n    .attr('alignment-baseline', 'middle')\r\n    .attr('class', 'text')\r\n    .style('font-size', textSize)\r\n    .text(`(${xval}, ${Math.round(yval)})`)\r\n}\r\n\r\nexport default LimitExampleGraph","/**\r\n * Renders Piecewise Function in Latex\r\n */\r\nimport React, { useEffect, useState } from \"react\";\r\nimport Latex from \"./Latex\";\r\nimport { PiecewiseFunction } from \"../../@types/PiecewiseFunction\";\r\n\r\ninterface PiecewiseProps {\r\n  title: string, // name of function\r\n  functions: PiecewiseFunction[], // functions to show\r\n  display?: string | boolean, // whether it should be display mode\r\n  classes?: string // classes to apply\r\n}\r\n\r\nexport const Piecewise: React.FC<PiecewiseProps> = ({ title, functions, display, classes }) => {\r\n  const [expression, setExpression] = useState(``);\r\n  useEffect(() => {\r\n    if (functions) {\r\n      let e = `\\\\begin{cases}`;\r\n      for (let i = 0; i < functions.length; i++) {\r\n        e = e + functions[i].f + \"&\";\r\n        e = e + functions[i].domain;\r\n        if (i !== functions.length - 1) {\r\n          e = e + \"\\\\\\\\\\\\\\\\\"\r\n        }\r\n      }\r\n      e = e + \"\\\\end{cases}\"\r\n      setExpression(e)\r\n    }\r\n  },[functions])\r\n  \r\n  return (\r\n    <>\r\n      <Latex classes={classes ? classes : \"\"} expression={`${title ? `${title} = ` : ''} ${expression}`} display={display} />\r\n    </>\r\n  )\r\n}","const FAR_DIST = window.outerWidth < 800 ? 1.3 : 1;\r\nconst CLOSE_DIST = window.outerWidth < 800 ? 0.5 : 0.3;\r\nconst AXIS_OFFSET = window.outerWidth < 800 ? 0.4 : 0.3;\r\nconst GRAPH_SIZE = window.outerWidth < 800 ? 250 : 400;\r\nconst COLORS = ['red', 'green', 'blue', 'orange', 'purple'];\r\nconst LEFT_LIMIT = `^{\\\\footnotesize\\\\texttt{-}}`\r\nconst RIGHT_LIMIT = `^{\\\\footnotesize\\\\texttt{+}}`\r\n\r\nexport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET, GRAPH_SIZE, COLORS, LEFT_LIMIT, RIGHT_LIMIT }","import * as d3 from 'd3';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { FAR_DIST, CLOSE_DIST, AXIS_OFFSET } from \"./constants\";\r\nimport { GraphFunction } from '../@types/GraphFunction';\r\nimport { DataPoint } from '../@types/DataPoint';\r\nimport { GraphFunctionData } from '../@types/GraphFunctionData';\r\nimport { GraphPoint } from '../@types/GraphPoint';\r\nimport { LimitPoints } from '../@types/LimitPoints';\r\n\r\n/**\r\n * generates graphing data for mathematical function\r\n * @param {function} f function for which to generate data\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @param {number} dataGap how close to generate function data\r\n * @returns array of data with generated values\r\n */\r\nconst generateFunctionData = (f: Function, min: number, max: number, dataGap: number = 0.01): DataPoint[] => {\r\n  let data = [];\r\n\r\n  for (let i = min; i <= max; i += dataGap) {\r\n    const x = i;\r\n    const y = f(i)\r\n    data.push({ x, y });\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * appends graph of a mathematical function on an svg\r\n * @param {svg} svg element on which to draw function graph\r\n * @param {function} f function to graph \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {color} color color of graph\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @param {string} classes custom string of classes to include in function path/arrows\r\n * @param {int} min domain minimum value\r\n * @param {int} max domain maximum value\r\n * @param {boolean} leftArrow whether there should be an arrow on the left of the graph\r\n * @param {boolean} rightArrow whether there should be an arrow on the right of the graph\r\n * @param {String} type can be \"asymptotic\"\r\n * @param {number} dataGap how close to generate function data\r\n * @returns data that was used to graph function, id of svg path of function\r\n */\r\nconst createFunctionGraph = (svg: any, f: Function, width: number, height: number,\r\n  color: string, xScale: any, yScale: any, classes: string, min: number,\r\n  max: number, leftArrow: boolean, rightArrow: boolean, type?: string, dataGap?: number): GraphFunctionData => {\r\n\r\n  let data = generateFunctionData(f, min, max, dataGap); // generate data\r\n\r\n  // filter data\r\n  data = data.filter((d) => d.x > Math.min(xScale.invert(0), max) &&\r\n    d.x < Math.max(xScale.invert(width), min) &&\r\n    d.y > yScale.invert(height) &&\r\n    d.y < yScale.invert(0))\r\n\r\n  if (type === \"asymptotic\") {\r\n    // make left part of graph go to edge\r\n    if (min > xScale.invert(0)) {\r\n      // get data point of intersection with top/bottom of graph\r\n      const y = data[0].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, min + 0.00001, data[0].x, 0.01);\r\n      if (d) data.unshift({ x: d, y: f(d) }); // add point to beginning of data\r\n    }\r\n\r\n    // make right part of graph go to edge\r\n    if (max < xScale.invert(width)) {\r\n      // data point of intersection with top/bottom\r\n      const y = data[data.length - 1].y > 0 ? yScale.invert(0) : yScale.invert(height)\r\n      let d = findIntersections(f, y, data[data.length - 1].x, max - 0.00001, 0.01);\r\n      if (d) data.push({ x: d, y: f(d) }); // add point to end of data\r\n    }\r\n  }\r\n\r\n  const line = d3.line()\r\n    .x(d => xScale(d.x))\r\n    .y(d => yScale(d.y))\r\n\r\n  // arrow markers for graph\r\n  const markerSize = 5;\r\n  const name = `${uuidv4()}function-arrow`\r\n  createArrowMarker(name, svg, markerSize, color, classes)\r\n\r\n  // create graph\r\n  const id = uuidv4();\r\n  svg.append('path')\r\n    .datum(data)\r\n    .attr('data-uuid', id)\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('fill', 'none')\r\n    .attr('stroke', color)\r\n    .attr('stroke-width', 2)\r\n    .attr('marker-end', rightArrow ? `url(#${name})` : null)\r\n    .attr('marker-start', leftArrow ? `url(#${name})` : null)\r\n    .attr('d', line);\r\n\r\n  svg.select(\".tick-text\").raise(); // raise tickmarks on top\r\n  svg.select(\".tick-marks\").raise(); // raise tickmarks on top\r\n\r\n  return { data, id };\r\n}\r\n\r\n/**\r\n * \r\n * @param {function} func for which to find intersections\r\n * @param {number} y of intersection point\r\n * @param {number} xMin of domain\r\n * @param {number} xMax of domain\r\n * @param {number} tolerance for how far away ans can be from y\r\n * @returns xvalue at which there is intersection\r\n */\r\nconst findIntersections = (func: Function, y: number, xMin: number, xMax: number, tolerance: number): number => {\r\n  var a = xMin;\r\n  var b = xMax;\r\n\r\n  // binary search\r\n  while (b - a > 0.00001) {\r\n    var xMid = (a + b) / 2;\r\n    var yMid = func(xMid);\r\n\r\n    if (y > 0 && yMid <= y && y - yMid < tolerance) {\r\n      return xMid;\r\n    }\r\n    if (y < 0 && yMid >= y && yMid - y < tolerance) {\r\n      return xMid;\r\n    }\r\n\r\n    // update based on graph behavior\r\n    if (func(xMin) < func(xMax) && yMid < y) {\r\n      // increasing graph, y too low\r\n      a = xMid;\r\n    } else if (func(xMin) < func(xMax)) {\r\n      // increasing graph, y too high\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax) && yMid < y) {\r\n      // decreasing graph, y too low\r\n      b = xMid;\r\n    } else if (func(xMin) > func(xMax)) {\r\n      // decreasing graph, y too high\r\n      a = xMid;\r\n    }\r\n  }\r\n\r\n  return (a + b) / 2; // nothing found so get midpoint\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg on which to draw function graph\r\n * @param {Array} functions to graph, each has the f, min/max domain, and includesLeft/includesRight, which indicates whether min/max are included or not\r\n * @param {int} width of svg\r\n * @param {int} height of svg\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @returns {Array} array of all data and ids of function graphs\r\n */\r\nconst createMultipleFunctionsGraph = (svg: any, functions: GraphFunction[], width: number, height: number, xScale: any, yScale: any): { dataArray: GraphFunctionData[] } => {\r\n  const dataArray = [];\r\n\r\n  for (let i = 0; i < functions.length; i++) {\r\n    // add graph for each function\r\n    const func = functions[i];\r\n    const { data, id } = createFunctionGraph(svg, func.f, width, height, null, xScale, yScale, func.classes, func.min, func.max, func.leftArrow, func.rightArrow, func.type, func.dataGap);\r\n\r\n    dataArray[dataArray.length] = { data, id }; // save return values\r\n\r\n    // append circles as holes/points if needed\r\n    if (func.leftCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeLeft ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.min))\r\n        .attr('cy', yScale(func.f(func.min)))\r\n        .attr('r', 3)\r\n    }\r\n\r\n    if (func.rightCircle) {\r\n      svg\r\n        .append('circle')\r\n        .attr('class', 'fill stroke ' + (func.includeRight ? '' : 'hole ') + func.classes)\r\n        .attr('cx', xScale(func.max))\r\n        .attr('cy', yScale(func.f(func.max)))\r\n        .attr('r', 3)\r\n    }\r\n  }\r\n\r\n  return { dataArray }\r\n}\r\n\r\n/**\r\n * Adds points to svg \r\n * @param {svg} svg svg on which to add points\r\n * @param {Array} points to add\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n */\r\nconst addPointsToGraph = (svg: any, points: GraphPoint[], xScale: any, yScale: any) => {\r\n  for (let i = 0; i < points.length; i++) {\r\n    svg\r\n      .append('circle')\r\n      .attr('class', 'fill stroke ' + points[i].classes)\r\n      .attr('cx', xScale(points[i].x))\r\n      .attr('cy', yScale(points[i].y))\r\n      .attr('r', 3)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * creates -10 by 10 (default, diff dimensions can be specified) blank canvas on top of which graphs can be drawn \r\n * @param {number} width width of graph\r\n * @param {number} height height of graph\r\n * @param {Ref} svgRef reference to svg where graph should be drawn\r\n * @param {number} textSize size of text of graph labels\r\n * @param {number} minx minimum domain value\r\n * @param {number} maxx maximum domain value\r\n * @param {number} miny minimum range value\r\n * @param {number} maxy maximum range value\r\n * @returns width, height, xscale, and yscale of graph\r\n */\r\nconst createBlankCanvas = (width: number, height: number, svgRef: React.RefObject<HTMLCanvasElement>, textSize: number, minx: number = -10, maxx: number = 10, miny: number = -10, maxy: number = 10): { width: number, height: number, xScale: any, yScale: any } => {\r\n  const numCells = 20;\r\n  const half = (width / 2) / numCells;\r\n  const color = \"#707070\"\r\n  const size = 5;\r\n\r\n  const svg = d3.select(svgRef.current);\r\n  svg.selectAll(\"*\").remove();\r\n\r\n  svg\r\n    .attr('width', width)\r\n    .attr('height', height)\r\n\r\n  // scales\r\n  const xScale = d3.scaleLinear()\r\n    .domain([minx, maxx])\r\n    .range([half, width - half]);\r\n\r\n  const yScale = d3.scaleLinear()\r\n    .domain([miny, maxy])\r\n    .range([-1 * half + height, half]);\r\n\r\n  // build tick marks on axes\r\n  const tickMarks = svg.append('g')\r\n    .attr('class', 'tick-marks');\r\n\r\n  const tickText = svg.append('g')\r\n    .attr('class', 'tick-text')\r\n\r\n  const xGrid = svg.append('g')\r\n    .attr('class', 'x-grid-line')\r\n\r\n  const yGrid = svg.append('g')\r\n    .attr('class', 'y-grid-line')\r\n\r\n\r\n  const tickCount = 20;\r\n  const tickCount2 = tickCount / 2;\r\n\r\n  const ticks = d3.range(tickCount + 1).map((d, i) => minx + (i * ((maxx - minx) / tickCount)));\r\n  const ticks2 = d3.range(tickCount2 + 1).map((d, i) => minx + (i * ((maxx - minx) / tickCount2)));\r\n\r\n  ticks.forEach(tick => {\r\n    xGrid.append(\"line\")\r\n      .attr(\"x1\", xScale(tick))\r\n      .attr(\"x2\", xScale(tick))\r\n      .attr(\"y1\", 0)\r\n      .attr(\"y2\", height)\r\n      .attr(\"stroke\", \"lightgray\");\r\n  })\r\n\r\n  // add marks and text to xaxis\r\n  ticks2.forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(tick))\r\n      .attr(\"x2\", xScale(tick))\r\n      .attr(\"y1\", yScale(0) - 4)\r\n      .attr(\"y2\", yScale(0) + 4)\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(tick) + (tick < 0 ? 1.5 : -1.5))\r\n      .attr(\"y\", yScale(0) + 3)\r\n      .attr('alignment-baseline', 'hanging')\r\n      .attr('text-anchor', tick < 0 ? 'start' : 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(Math.round(tick * 100) / 100)\r\n  })\r\n\r\n  ticks.forEach(tick => {\r\n    yGrid.append(\"line\")\r\n      .attr(\"class\", \"y-grid-line\")\r\n      .attr(\"x1\", 0)\r\n      .attr(\"x2\", width)\r\n      .attr(\"y1\", yScale(tick))\r\n      .attr(\"y2\", yScale(tick))\r\n      .attr(\"stroke\", \"lightgray\");\r\n  })\r\n\r\n  // add marks and text to y axis\r\n  ticks2.forEach(tick => {\r\n    tickMarks.append(\"line\")\r\n      .attr(\"x1\", xScale(0) - 4)\r\n      .attr(\"x2\", xScale(0) + 4)\r\n      .attr(\"y1\", yScale(tick))\r\n      .attr(\"y2\", yScale(tick))\r\n      .attr(\"stroke\", tick === 0 ? \"none\" : color)\r\n      .attr(\"stroke-width\", 1)\r\n\r\n    tickText.append(\"text\")\r\n      .attr(\"x\", xScale(0) - 3)\r\n      .attr(\"y\", yScale(tick) + (tick < 0 ? -1.5 : 1.5))\r\n      .attr('alignment-baseline', tick < 0 ? 'baseline' : 'hanging')\r\n      .attr('text-anchor', 'end')\r\n      .style('color', 'black')\r\n      .style('font-size', tick === 0 ? 0 : textSize - 4)\r\n      .attr('font-weight', 'bold')\r\n      .text(Math.round(tick * 100) / 100)\r\n  })\r\n\r\n  // draw actual x and y axes\r\n  const name = \"axes-arrow\"\r\n  createArrowMarker(name, svg, size, color);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", 0)\r\n    .attr(\"x2\", width)\r\n    .attr(\"y1\", yScale(0))\r\n    .attr(\"y2\", yScale(0))\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  svg.append(\"line\")\r\n    .attr(\"x1\", xScale(0))\r\n    .attr(\"x2\", xScale(0))\r\n    .attr(\"y1\", height)\r\n    .attr(\"y2\", 0)\r\n    .attr(\"stroke\", color)\r\n    .attr(\"stroke-width\", 2)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('marker-start', `url(#${name})`);\r\n\r\n  return { width, height, xScale, yScale }\r\n};\r\n\r\n/**\r\n * generates custom arrow marker to be used in graphs of functions\r\n * @param {string} name identifier name of arrow marker being generated\r\n * @param {svg} svg svg where marker should be appended\r\n * @param {number} size size of marker\r\n * @param {string} color color of marker\r\n * @param {string} classes custom classes to be added to marker\r\n */\r\nconst createArrowMarker = (name: string, svg: any, size: number, color: string, classes?: string) => {\r\n  svg.append(\"defs\").append(\"marker\")\r\n    .attr(\"id\", name)\r\n    .attr('class', 'fill ' + classes)\r\n    .attr(\"refX\", size)\r\n    .attr(\"refY\", size / 2)\r\n    .attr(\"markerWidth\", size)\r\n    .attr(\"markerHeight\", size)\r\n    .attr(\"orient\", \"auto-start-reverse\")\r\n    .attr('fill', color)\r\n    .append(\"path\")\r\n    .attr(\"d\", `M0,0 V${size} Q${size * 2},${size / 2} 0,0`)\r\n}\r\n\r\n/**\r\n * \r\n * @param {svg} svg svg in which to append limit line\r\n * @param {function} line function for 'd' attribute of path\r\n * @param {number} x1 x1 of line\r\n * @param {number} x2 x2 of line\r\n * @param {number} y1 y1 of line\r\n * @param {number} y2 y2 of line\r\n * @param {string} name of arrow markers on line\r\n * @param {string} classes custom classes o add to generated arrow\r\n */\r\nconst createLimitLine = (svg: any, line: Function, x1: number, x2: number, y1: number, y2: number, name: string, classes: string) => {\r\n  // check if arrow marker exists\r\n  if (d3.select(`#${name}`).empty()) {\r\n    createArrowMarker(name, svg, 4, null, classes)\r\n  }\r\n\r\n  // add limit line\r\n  svg.append('path')\r\n    .datum([{ x: x1, y: y1 }, { x: x2, y: y2 }])\r\n    .attr('class', 'stroke ' + classes)\r\n    .attr('stroke-width', 1)\r\n    .attr('marker-end', `url(#${name})`)\r\n    .attr('d', line)\r\n}\r\n\r\n/**\r\n * finds hypotenuse frm width/height of triangle\r\n * @param {number} x width\r\n * @param {number} y height\r\n * @returns hypotenuse of triangle formed with width/height\r\n */\r\nconst findHypotenusefromSlope = (x: number, y: number): number => {\r\n  return Math.sqrt(((x) ** 2) + ((y) ** 2))\r\n}\r\n\r\n/**\r\n * converts points from svg scale to normal -10 to 10 x/y\r\n * @param {object} far far point\r\n * @param {object} close close point\r\n * @param {scale} xScale xscale of graph\r\n * @param {scale} yScale yscale of graph\r\n * @returns points object with converted x/y values\r\n */\r\nconst convertScale = (far: DataPoint, close: DataPoint, xScale: any, yScale: any): LimitPoints => {\r\n  const farx = xScale.invert(far.x)\r\n  const closex = xScale.invert(close.x)\r\n  const fary = yScale.invert(far.y)\r\n  const closey = yScale.invert(close.y)\r\n  return { farx, closex, fary, closey }\r\n}\r\n\r\n/**\r\n * perpendicular slope from points\r\n * @param {object} points object representing points from which to compute slope\r\n * @returns perpendicular slope from points\r\n */\r\nconst findSlope = (points: LimitPoints): number => {\r\n  let ans = (-1 * (points.farx - points.closex)) / (points.fary - points.closey)\r\n  return ans;\r\n}\r\n\r\n/**\r\n * Finds offsets of lines/text from function line\r\n * @param {object} points object representing points from which line needs to be offset\r\n * @param {number} axisOffset how much line should be offset\r\n * @returns x, y representing by how much lines need to move in each direction\r\n */\r\nconst findOffsets = (points: LimitPoints, axisOffset: number): DataPoint => {\r\n  let slope = findSlope(points)\r\n  const hyp = findHypotenusefromSlope(1, slope);\r\n  let scale = -1 * axisOffset / hyp;\r\n  if (slope > 0) scale *= -1\r\n  const x = scale;\r\n  const y = (scale) * slope;\r\n\r\n  return { x, y }\r\n}\r\n\r\n\r\n/**\r\n * \r\n * @param {svg} svg on which to append lines\r\n * @param {Element} functionLine line for function\r\n * @param {int} pathLength length of path up till point\r\n * @param {scale} xScale of svg\r\n * @param {scale} yScale of svg\r\n * @param {function} line function that creates 'd' attribute in svg path\r\n * @param {String} fColor color of function\r\n * @param {boolean} right true if the limit line to be drawn should be from the right, false if left\r\n * @param {String} markerName custom name of arrow marker\r\n * @returns points of the line in svg scale\r\n */\r\n\r\nconst createFunctionLimitLine = (svg: any, functionLine: any, pathLength: number, xScale: any, yScale: any, line: Function, fColor: string, right: boolean, markerName?: string): { closePoint: DataPoint, farPoint: DataPoint } => {\r\n\r\n  // modify lengths based on if the arrow is from the left or the right\r\n  let farDistLength = xScale(FAR_DIST) - xScale(0);\r\n  farDistLength = right ? farDistLength : (-1 * farDistLength);\r\n  let closeDistLength = xScale(CLOSE_DIST) - xScale(0);\r\n  closeDistLength = right ? closeDistLength : (-1 * closeDistLength)\r\n\r\n  // arrow from the left\r\n  const farPoint = functionLine.getPointAtLength(pathLength + farDistLength)\r\n  const closePoint = functionLine.getPointAtLength(pathLength + closeDistLength)\r\n  const pointsOne = convertScale(farPoint, closePoint, xScale, yScale)\r\n  const offsetsOne = findOffsets(pointsOne, AXIS_OFFSET);\r\n\r\n  if (isNaN(offsetsOne.y)) offsetsOne.y = AXIS_OFFSET;\r\n\r\n  createLimitLine(svg, line,\r\n    pointsOne.farx + offsetsOne.x,\r\n    pointsOne.closex + offsetsOne.x,\r\n    pointsOne.fary + offsetsOne.y,\r\n    pointsOne.closey + offsetsOne.y,\r\n    markerName ? markerName : 'f-limits', fColor)\r\n\r\n  return { closePoint, farPoint }\r\n}\r\n\r\nexport { createFunctionGraph, createBlankCanvas, createArrowMarker, generateFunctionData, createLimitLine, findHypotenusefromSlope, convertScale, findSlope, findOffsets, createMultipleFunctionsGraph, createFunctionLimitLine, addPointsToGraph }\r\n","import LimitExampleGraph from \"../../../components/content-components/graphs/LimitExampleGraph\"\r\nimport Latex from \"../../../components/latex/Latex\"\r\nimport * as math from 'mathjs'\r\nimport { GRAPH_SIZE } from \"../../../helpers/constants\"\r\nimport React from \"react\"\r\nimport { PiecewiseFunction } from \"../../../@types/PiecewiseFunction\"\r\nimport { Piecewise } from \"../../../components/latex/Piecewise\"\r\n\r\n/**\r\n * All content for this topic's learn section\r\n * all these components represent content for the sections\r\n */\r\nconst Section1 = () => {\r\n  return (\r\n    <div>\r\n      In Calculus, a limit describes how a function behaves <strong>near</strong> a point, instead of <strong>at</strong> that point.\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Section2 = () => {\r\n  return (\r\n    <div>\r\n      A limit is written as <Latex expression={`\\\\ {\\\\lim}`} classes={'c1'} inline={true} />\r\n      <Latex expression={`_{x \\\\to a}`} classes={'c2'} inline={true} />\r\n      <Latex expression={`f(x)`} classes={'c3'} inline={true} />\r\n      <Latex expression={`\\\\ =\\\\ `} inline={true} />\r\n      <Latex expression={`\\\\ L `} classes={'c4'} inline={true} />.\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Section3 = () => {\r\n  return (\r\n    <div>\r\n      This is read as \"the\r\n      <span className=\"c1\"> limit</span> of\r\n      <Latex expression={`f(x)`} classes={'c3'} inline={true} />\r\n      <span className=\"c2\"> as\r\n        <Latex expression={`\\\\ x\\\\ `} inline={true} />\r\n        approaches\r\n        <Latex expression={`\\\\ a\\\\ `} inline={true} />\r\n      </span>\r\n      is <Latex classes=\"c4\" expression={`\\\\ L\\\\ `} inline={true} />\".\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Section4 = () => {\r\n  return (\r\n    <div>\r\n      To understand this, let’s look at an example:\r\n      <Latex expression={`\\\\ {\\\\lim}`} classes={'c1'} inline={true} />\r\n      <Latex expression={`_{x \\\\to 2}`} classes={'c2'} inline={true} />\r\n      <Latex expression={`x^2`} classes={'c3'} inline={true} />\r\n      <Latex expression={`\\\\ =\\\\ `} inline={true} />\r\n      <Latex expression={`\\\\ 4 `} classes={'c4'} inline={true} />.\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\nconst Section5 = () => {\r\n  const expression = 'x^2';\r\n  const node = math.parse(expression);\r\n  const f = x => node.evaluate({ x });\r\n  const xval = 2;\r\n  const fColor = 'c3';\r\n  const xColor = 'c2';\r\n  const yColor = 'c4';\r\n\r\n  return (\r\n    <>\r\n      <div>\r\n        Conceptually, this means that the value of the\r\n        <span className=\"c3\"> function </span>\r\n        (in this case <Latex classes={'c3'} expression={`${node.toTex()}`} inline={true} />) gets closer and closer to <span className=\"c4\">4</span> as the x-value gets closer and closer to <span className=\"c2\">2</span>.\r\n      </div>\r\n      <div className='flex vertical center'>\r\n        <h3>Graph of <Latex expression={`${node.toTex()}`} inline={true} /></h3>\r\n        <LimitExampleGraph f={f} xval={xval} y={f(xval)} fColor={fColor} xColor={xColor} yColor={yColor} size={GRAPH_SIZE} />\r\n      </div>\r\n    </>\r\n  )\r\n}\r\n\r\nconst Section6 = () => {\r\n  return (\r\n    <div>\r\n      This does not necessarily mean that the value of <Latex classes={'c3'} expression={`f(x) = x^2`} inline={true} /><strong> at </strong> <Latex classes={'c2'} expression={`x = 2`} inline={true} /> is <Latex classes={'c4'} expression={`4`} inline={true} />!\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Section7 = () => {\r\n  const expression = 'x^2';\r\n  const node = math.parse(expression);\r\n  const f = x => node.evaluate({ x });\r\n  const xval = 2;\r\n  const fColor = 'c3';\r\n  const xColor = 'c2';\r\n  const yColor = 'c4';\r\n  const piecewiseFunctions: PiecewiseFunction[] = [\r\n    { f: `x^2`, domain: `x \\\\neq 2` },\r\n    { f: `6`, domain: `x = 2` }\r\n  ]\r\n  return (\r\n    <>\r\n      <div>As an example, let's look at this function:\r\n      </div>\r\n      <div>\r\n        <Piecewise title=\"g(x)\" functions={piecewiseFunctions} display={true}/>\r\n      </div>\r\n      <div className='flex vertical center'>\r\n        <h3>Graph of <Latex expression={`g(x)`} inline={true} /></h3>\r\n        <LimitExampleGraph f={f} xval={xval} y={6} fColor={fColor} xColor={xColor} yColor={yColor} size={GRAPH_SIZE} />\r\n      </div>\r\n    </>\r\n  )\r\n}\r\n\r\nconst Section8 = () => {\r\n  return (\r\n    <div>\r\n      In this case,\r\n      <Latex expression={`\\\\ {\\\\lim}`} classes={'c1'} inline={true} />\r\n      <Latex expression={`_{x \\\\to 2}`} classes={'c2'} inline={true} />\r\n      <Latex expression={`x^2`} classes={'c3'} inline={true} />\r\n      <Latex expression={`\\\\ =\\\\ `} inline={true} />\r\n      <Latex expression={`\\\\ 4\\\\ `} classes={'c4'} inline={true} />\r\n      is <strong>still </strong><Latex expression={`4`} classes={`c4`} inline={true} />,\r\n      because <strong>near </strong>\r\n      <Latex classes='c2' expression={`x = 2`} inline={true} />,\r\n      <Latex classes='c3' expression={`\\\\ g(x)`} inline={true} /> is getting closer and closer to <Latex classes='c4' expression={`4`} inline={true} />.\r\n    </div>\r\n  )\r\n}\r\n\r\nexport { Section1, Section2, Section3, Section4, Section5, Section6, Section7, Section8 }\r\n\r\n\r\n\r\n//////////////////// UNUSED  ///////////////////////////\r\n\r\n/*\r\nconst Section5 = () => {\r\n  return (\r\n    <div>\r\n      Can you guess what this means?\r\n    </div>\r\n  )\r\n}\r\n\r\nconst Section6 = () => {\r\n  return (\r\n    <div>\r\n      This means that the <span className=\"c1\">limit</span> of \r\n      <span className=\"c3\" dangerouslySetInnerHTML={{__html: ` \\\\(x^2\\\\) `}} />\r\n      <span className=\"c2\">as \r\n        <span dangerouslySetInnerHTML={{__html: ` \\\\(x\\\\) `}} /> approaches \r\n        <span dangerouslySetInnerHTML={{__html: ` \\\\(2\\\\) `}} /> \r\n      </span> is \r\n      <span className=\"c4\" dangerouslySetInnerHTML={{__html: ` \\\\(4\\\\) `}} />\r\n    </div>\r\n  )\r\n}\r\n*/","import { Section1, Section2, Section3, Section4, Section5, Section6, Section7, Section8 } from \"./Sections\"\r\nimport React from \"react\"\r\n\r\n/**\r\n * array of content to be shown on learn page\r\n */\r\nconst learnContent = [\r\n  <Section1 />,\r\n  <Section2 />,\r\n  <Section3 />,\r\n  <Section4 />,\r\n  <Section5 />,\r\n  <Section6 />,\r\n  <Section7 />,\r\n  <Section8 />,\r\n]\r\n\r\nexport default learnContent"],"names":["_ref","f","xval","y","fColor","xColor","yColor","size","svgRef","useRef","useEffect","current","textSize","graphSize","height","width","xScale","yScale","createBlankCanvas","svg","d3","yval","line","x","d","append","datum","attr","style","data","id","createFunctionGraph","createLimitLine","FAR_DIST","CLOSE_DIST","AXIS_OFFSET","dataUpToPoint","filter","pointId","uuidv4","functionLine","concat","node","pathLength","getTotalLength","leftLine","createFunctionLimitLine","rightLine","farPointOne","farPoint","farPointTwo","pointsText","convertScale","offsetsText","findOffsets","isNaN","Math","min","max","text","round","createAllLimitLines","_jsx","ref","Piecewise","title","functions","display","classes","expression","setExpression","useState","e","i","length","domain","_Fragment","children","Latex","window","outerWidth","GRAPH_SIZE","COLORS","generateFunctionData","dataGap","arguments","undefined","push","color","leftArrow","rightArrow","type","invert","findIntersections","unshift","name","createArrowMarker","select","raise","func","xMin","xMax","tolerance","a","b","xMid","yMid","createMultipleFunctionsGraph","dataArray","leftCircle","includeLeft","rightCircle","includeRight","addPointsToGraph","points","minx","maxx","miny","maxy","half","selectAll","remove","range","tickMarks","tickText","xGrid","yGrid","ticks","tickCount","map","ticks2","tickCount2","forEach","tick","x1","x2","y1","y2","empty","far","close","farx","closex","fary","closey","axisOffset","slope","findSlope","hyp","findHypotenusefromSlope","sqrt","scale","right","markerName","farDistLength","closeDistLength","getPointAtLength","closePoint","pointsOne","offsetsOne","Section1","_jsxs","Section2","inline","Section3","className","Section4","Section5","math","evaluate","toTex","LimitExampleGraph","Section6","Section7","Section8"],"sourceRoot":""}